package db

import (
	"fmt"
	"reflect"
	"strings"
)

type columnInfo struct {
	Name      string
	FieldType string
	//FieldName      string
	NameAlias string
	Type      string
	IsSlice   bool
	// RefType        reflect.Value
	MethodIdx       int
	IsPrimaryKey    int8
	IsPointer       bool
	IsViewExcluded  bool
	IsAutogenerated bool
	HasView         bool
	IsComplexType   bool
	ViewIdx         int8
	getValue        func(s *reflect.Value) any
}

var scyllaFieldToColumnTypesMap = map[string]string{
	"string":  "text",
	"int":     "int",
	"int32":   "int",
	"int64":   "bigint",
	"int64.1": "counter",
	"int16":   "smallint",
	"int8":    "tinyint",
	"float32": "float",
	"float64": "double",
}

var makeStatementWith string = `
	WITH caching = {'keys': 'ALL', 'rows_per_partition': 'ALL'}
	and compaction = {'class': 'SizeTieredCompactionStrategy'}
	and compression = {'compression_level': '3', 'sstable_compression': 'org.apache.cassandra.io.compress.ZstdCompressor'}
	and dclocal_read_repair_chance = 0
	and speculative_retry = '99.0PERCENTILE'`

func makeTable[T TableSchemaInterface]() scyllaTable {
	newT := *new(T)
	schema := newT.GetTableSchema()

	dbTable := scyllaTable{
		name:         schema.Name,
		partitionKey: schema.Partition.GetInfo(),
		primaryKey:   schema.Partition.GetInfo(),
		columnsMap:   map[string]columnInfo{},
		indexes:      map[string]viewInfo{},
		views:        map[string]viewInfo{},
	}

	refTyp := reflect.ValueOf(newT)
	methodsPrefix := []string{"func() db.ColSlice[", "func() db.Col["}

	for i := 0; i < refTyp.NumMethod(); i++ {
		method := refTyp.Method(i)
		methodType := method.Type().String()
		founded := false
		for _, mp := range methodsPrefix {
			if strings.HasPrefix(methodType, mp) {
				founded = true
			}
		}
		if !method.IsValid() || !founded {
			continue
		}

		colBase := method.Call(nil)[0]
		if col, ok := colBase.Interface().(ColInfo); ok {
			columnInfo := col.GetInfo()
			fmt.Println("Column Name:", columnInfo.Name, "| Type:", columnInfo.FieldType, "| Is Slice:", columnInfo.IsSlice)

			columnInfo.getValue = func(rv *reflect.Value) any {
				if cb, ok := rv.Method(i).Call(nil)[0].Interface().(ColInfo); ok {
					return cb.GetValue()
				}
				return nil
			}
			columnInfo.Type = scyllaFieldToColumnTypesMap[columnInfo.FieldType]
			if columnInfo.Type == "" {
				columnInfo.IsComplexType = true
				columnInfo.Type = "blob"
			} else if columnInfo.IsSlice {
				columnInfo.Type = fmt.Sprintf("set<%v>", columnInfo.Type)
			}
			dbTable.columnsMap[columnInfo.Name] = columnInfo
			dbTable.columns = append(dbTable.columns, columnInfo)
		}
	}

	idxCount := int8(1)
	for _, column := range schema.GlobalIndexes {
		colInfo := dbTable.columnsMap[column.GetInfo().Name]
		index := viewInfo{
			iType:   1,
			name:    fmt.Sprintf(`%v__%v_index_0`, dbTable.name, colInfo.Name),
			idx:     idxCount,
			column:  colInfo,
			columns: []string{colInfo.Name},
			getValue: func(s *reflect.Value) any {
				return colInfo.getValue(s)
			},
			getStatement: func(statements ...ColumnStatement) string {
				if len(statements) != 1 {
					panic(fmt.Sprintf("Error columna %v: El número de valores debe ser = 1", colInfo.Name))
				}
				st := statements[0]
				return fmt.Sprintf("%v %v %v", colInfo.Name, st.Operator, st.Value)
			},
		}
		index.getCreateScript = func() string {
			return fmt.Sprintf(`CREATE INDEX %v ON %v (%v)`,
				index.name, schema.Name, column.GetInfo().Name)
		}

		idxCount++
		dbTable.indexes[index.name] = index
	}

	for _, column := range schema.LocalIndexes {
		colInfo := column.GetInfo()
		index := viewInfo{
			iType:   2,
			name:    fmt.Sprintf(`%v__%v_index_1`, dbTable.name, colInfo.Name),
			idx:     idxCount,
			columns: []string{dbTable.partitionKey.Name, colInfo.Name},
			getValue: func(s *reflect.Value) any {
				return colInfo.getValue(s)
			},
			getStatement: func(sts ...ColumnStatement) string {
				if len(sts) != 2 {
					panic(fmt.Sprintf("Error columna %v: El número de valores debe ser = 2", colInfo.Name))
				}
				return fmt.Sprintf("%v = %v AND %v %v %v", dbTable.partitionKey.Name, sts[0].Value, colInfo.Name, sts[1].Operator, sts[1].Value)
			},
		}
		index.getCreateScript = func() string {
			return fmt.Sprintf(`CREATE INDEX %v ON %v ((%v)%v)`,
				index.name, schema.Name, index.columns[0], index.columns[1])
		}

		idxCount++
		dbTable.indexes[index.name] = index
	}

	for _, indexColumns := range schema.HashIndexes {
		columns := []columnInfo{}
		names := []string{}

		for _, col := range indexColumns {
			name := col.GetInfo().Name
			names = append(names, name)
			columns = append(columns, dbTable.columnsMap[name])
		}
		colnames := strings.Join(names, "_")
		column := columnInfo{
			Name:      fmt.Sprintf(`zz_%v`, colnames),
			FieldType: "int32", Type: "int", IsAutogenerated: true,
		}

		index := viewInfo{
			iType:   3,
			name:    fmt.Sprintf(`%v__%v_index`, dbTable.name, colnames),
			idx:     idxCount,
			columns: names,
			column:  column,
			getValue: func(s *reflect.Value) any {
				values := []string{}
				for _, e := range columns {
					values = append(values, fmt.Sprintf("%v", e.getValue(s)))
				}
				return BasicHashInt(strings.Join(values, "|"))
			},
		}
		index.getStatement = func(statements ...ColumnStatement) string {
			if len(statements) < 2 {
				panic(fmt.Sprintf("Error columna %v: El número de valores debe ser >= 2", index.name))
			}

			values := []string{}
			for _, e := range statements {
				values = append(values, fmt.Sprintf("%v", e.Value))
			}
			hashInt := BasicHashInt(strings.Join(values, "|"))
			// Revisar casuísica IN
			return fmt.Sprintf("%v %v %v", index.column.Name, statements[0].Operator, hashInt)
		}
		index.getCreateScript = func() string {
			return fmt.Sprintf(`CREATE INDEX %v ON %v (%v)`,
				index.name, schema.Name, index.column.Name)
		}

		idxCount++
		dbTable.indexes[index.name] = index
	}

	for _, viewConfig := range schema.Views {
		columns := []columnInfo{}
		names := []string{}

		for _, col := range viewConfig.Cols {
			name := col.GetInfo().Name
			names = append(names, name)
			columns = append(columns, dbTable.columnsMap[name])
		}

		colnames := strings.Join(names, "_")
		view := viewInfo{
			iType:   4,
			name:    fmt.Sprintf(`%v__%v_view`, dbTable.name, colnames),
			columns: names,
		}

		if len(columns) > 1 {
			view.column = columnInfo{
				Name: fmt.Sprintf(`zz_%v`, colnames), IsAutogenerated: true,
			}
		}

		// Si sólo es una columna, no es necesario autogenerar
		if len(columns) == 1 {
			view.column = columns[0]
			view.getValue = func(s *reflect.Value) any {
				return view.column.getValue(s)
			}
		} else if viewConfig.Int64ConcatRadix > 0 {
			// Si ha especificado un int64 radix entonces se puede concatener, maximo 2 columnas
			if len(columns) != 2 {
				panic(fmt.Sprintf(`La view "%v" de la tabla "%v" posee más de 2 columnas para usar el Int64ConcatRadix`, dbTable.name, view.name))
			}

			view.getValue = func(s *reflect.Value) any {
				return view.column.getValue(s)
			}
		} else {
			// Sino crea un hash de las columnas
			view.getValue = func(s *reflect.Value) any {
				return view.column.getValue(s)
			}
		}

		whereCols := []columnInfo{view.column, dbTable.primaryKey}
		pk := whereCols[0].Name + ", " + whereCols[1].Name

		if len(dbTable.partitionKey.Name) > 0 {
			whereCols = append([]columnInfo{dbTable.partitionKey}, whereCols...)
			pk = fmt.Sprintf("(%v), %v", whereCols[0].Name, pk)
		}

		whereColumnsNotNull := []string{}
		for _, col := range whereCols {
			if col.Type == "text" {
				whereColumnsNotNull = append(whereColumnsNotNull, col.Name+" > ''")
			} else if col.IsSlice {
				whereColumnsNotNull = append(whereColumnsNotNull, col.Name+" IS NOT NULL")
			} else {
				whereColumnsNotNull = append(whereColumnsNotNull, col.Name+" > 0")
			}
		}

		view.getCreateScript = func() string {
			query := fmt.Sprintf(`CREATE MATERIALIZED VIEW %v
			AS
			SELECT %v FROM %v
			WHERE %v
			PRIMARY KEY (%v)
			%v;`,
				view.name, "*", dbTable.name, strings.Join(whereColumnsNotNull, " AND "), pk, makeStatementWith)
			return query
		}

		dbTable.views[view.name] = view
	}

	return dbTable
}
