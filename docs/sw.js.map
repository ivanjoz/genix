{
  "version": 3,
  "sources": ["../src/lib/unmarshall.ts", "../src/core/sharedHelpers.ts", "../src/workers/service-worker-cache.ts", "../src/workers/service-worker.ts"],
  "sourcesContent": ["/**\n * Unmarshalls a compact JSON array serialized by the serialize Go library.\n * The input should be an array [keys, content].\n *\n * @param encoded The serialized data [keys, content]\n * @returns The unmarshalled object or array\n */\nexport const unmarshall = (encoded: any): any => {\n  if (!Array.isArray(encoded) || encoded.length !== 2) {\n    return encoded;\n  }\n\n  const [keysDef, content] = encoded;\n  if (!Array.isArray(keysDef)) {\n    return encoded;\n  }\n\n  // Map to store type definitions: typeId -> { orderIdx -> fieldName }\n  const keysMap: Record<number, { fields: Record<number, string>; maxIndex: number }> = {};\n  for (const k of keysDef) {\n    if (!Array.isArray(k)) continue;\n    const typeId = k[0];\n    const fields: Record<number, string> = {};\n    let maxIndex = -1;\n    for (let i = 1; i < k.length; i += 2) {\n      const idx = k[i];\n      const name = k[i + 1];\n      fields[idx] = name;\n      if (idx > maxIndex) maxIndex = idx;\n    }\n    keysMap[typeId] = { fields, maxIndex };\n  }\n\n  let lastTypeId: number | null = null;\n\n  /**\n   * Decodes a value recursively based on headers.\n   */\n  const decode = (val: any): any => {\n    if (!Array.isArray(val) || val.length === 0) {\n      return val;\n    }\n\n    const header = val[0];\n\n    // Header 1: New object type\n    // Format: [1, [typeId, ...skipIndices], ...values]\n    if (header === 1) {\n      if (val.length < 2) return val;\n      const refBlock = val[1];\n      if (!Array.isArray(refBlock)) return val;\n      const typeId = refBlock[0];\n      const skipIndices = new Set<number>();\n      for (let i = 1; i < refBlock.length; i++) {\n        skipIndices.add(refBlock[i]);\n      }\n      lastTypeId = typeId;\n      return populate(typeId, val.slice(2), skipIndices);\n    }\n\n    // Header 0: Same type as previous object\n    // Format: [0, [skipIndices]?, ...values]\n    if (header === 0) {\n      if (lastTypeId === null) return val;\n\n      let skipIndices = new Set<number>();\n      let valueStartIdx = 1;\n\n      if (Array.isArray(val[1])) {\n        const sub = val[1];\n        let isSkipBlock = false;\n\n        if (sub.length > 0) {\n          const h = sub[0];\n          // If first element is not a valid header (0, 1, 2, 3), it's definitely a skip block\n          if (typeof h === 'number' && h !== 0 && h !== 1 && h !== 2 && h !== 3) {\n            isSkipBlock = true;\n          } else {\n            // If it is 0, 1, 2, or 3, it could be a skip block OR a value of the first field.\n            // Go's logic checks if the first field type is primitive.\n            // In TS, we don't have types, so we use the header rule as a heuristic.\n            isSkipBlock = typeof h === 'number' && h !== 0 && h !== 1 && h !== 2 && h !== 3;\n          }\n        }\n\n        if (isSkipBlock) {\n          for (const s of sub) {\n            if (typeof s === 'number') skipIndices.add(s);\n          }\n          valueStartIdx = 2;\n        }\n      }\n\n      return populate(lastTypeId, val.slice(valueStartIdx), skipIndices);\n    }\n\n    // Header 2: Array of values\n    // Format: [2, ...items]\n    if (header === 2) {\n      const result = [];\n      for (let i = 1; i < val.length; i++) {\n        result.push(decode(val[i]));\n      }\n      return result;\n    }\n\n    // Header 3: Map of key-value pairs\n    // Format: [3, key1, val1, key2, val2, ...]\n    if (header === 3) {\n      const result: Record<string, any> = {};\n      for (let i = 1; i < val.length; i += 2) {\n        if (i + 1 < val.length) {\n          const key = String(val[i]);\n          result[key] = decode(val[i + 1]);\n        }\n      }\n      return result;\n    }\n\n    // Fallback for plain arrays (header \"Other\")\n    return val.map(decode);\n  };\n\n  /**\n   * Populates an object of a given type with values and skip indices.\n   */\n  const populate = (typeId: number, values: any[], skipIndices: Set<number>) => {\n    const typeDef = keysMap[typeId];\n    if (!typeDef) return values;\n\n    const { fields, maxIndex } = typeDef;\n    const obj: Record<string, any> = {};\n    let valIdx = 0;\n    for (let i = 0; i <= maxIndex; i++) {\n      if (skipIndices.has(i)) {\n        continue;\n      }\n      if (valIdx >= values.length) {\n        break;\n      }\n      const fieldName = fields[i];\n      if (fieldName) {\n        obj[fieldName] = decode(values[valIdx]);\n      }\n      valIdx++;\n    }\n    return obj;\n  };\n\n  return decode(content);\n};\n", "export const recreateObject = (obj: any, keysMap: Map<string,string|number>): any => {\n  if(Array.isArray(obj)){ return obj.map(x => recreateObject(x, keysMap)) }\n  if(typeof obj !== 'object' || !obj || !obj._){ return obj }\n  for(const [key, value] of Object.entries(obj)){\n    if(keysMap.has(key)){\n      const newKey = keysMap.get(key)\n      if(newKey === key){ continue }\n      obj[newKey] = value\n      delete obj[key]\n    }\n  }\n\n  for(let i = 0; i < obj._.length; i+=2){\n    const key = keysMap.get(obj._[i])\n    obj[key] = recreateObject(obj._[i+1], keysMap)\n  }\n  delete obj._\n  return obj\n}\n\nexport const simplifyObject = (obj: any, keysMap: Map<string,string|number>): any => {\n  if(Array.isArray(obj)){ return obj.map(x => simplifyObject(x, keysMap)) }\n\n  if(typeof obj !== 'object' || !obj){ return obj }\n\n  const newObj = { _: [] as any[] } as {[key: string]: any  }\n  for(const [key, value] of Object.entries(obj)){\n    if(!keysMap.has(key)){\n      const id = keysMap.get(\"__count__\") as number || 0\n      keysMap.set(key, id+1)\n      keysMap.set(\"__count__\", id+1) \n    }\n    const id = keysMap.get(key)\n    if(typeof id === 'string'){\n      newObj[id] = value\n    } else {\n      newObj._.push(keysMap.get(key), simplifyObject(value, keysMap))\n    }\n  }\n  return newObj\n}\n\nexport const recreateArray = (records: any[]) => {\n  const keysMap = (records.find(x => x._keysMap) || {})._keysMap\n  if(keysMap){\n    const newRecords: any[] = []\n    for(const e of records){\n      if(e._keysMap){ continue }\n      newRecords.push(recreateObject(e, keysMap))\n    }\n    return newRecords\n  } else {\n    return records\n  }\n}\n", "/// <reference lib=\"WebWorker\" />\n\"use-strict\"\n\nimport { recreateObject } from \"../core/sharedHelpers\"\n\n// Names of the two caches used in this version of the service worker.\n// Change to v2, etc. when you update any of the local resources, which will\n// in turn trigger the install event again.\nconst PRECACHE = 'precache-v2'\nconst CACHE_ASSETS = 'assets-v2'\nconst CACHE_STATIC = 'static-v2'\nexport const CACHE_APP = 'app'\nexport const HandlersMap: Map<number, (input: any) => Promise<any>> = new Map()\n\n// A list of local resources we always want to be cached.\nconst PRECACHE_URLS: string[] = [\n  // 'index.html',\n  // './', // Alias for index.html\n]\n\nconst parseFileExtension = (filename: string) => {\n  const ix1 = filename.indexOf(\"?\")\n  if (ix1 !== -1) filename = filename.substring(0, ix1)\n  const ix2 = filename.indexOf(\"@\")\n  if (ix2 !== -1) filename = filename.substring(0, ix2)\n  filename = filename.substring(filename.indexOf(\"/\", 8))\n  const ix3 = filename.lastIndexOf(\".\")\n  if (filename === \"/\" || (ix3 === -1 && filename[2]) === \"/\") {\n    return [filename, \"*\"]\n  }\n  return [filename, filename.substring(ix3 + 1)]\n}\n\ndeclare const self: ServiceWorkerGlobalScope & {\n  __WB_MANIFEST: string[]\n  _isLocal: boolean\n};\n\n// The install handler takes care of precaching the resources we always need.\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(PRECACHE)\n      .then(cache => cache.addAll(PRECACHE_URLS))\n      .then(() => self.skipWaiting())\n  )\n})\n\n// The activate handler takes care of cleaning up old caches.\nself.addEventListener('activate', event => {\n  const currentCaches = [PRECACHE, CACHE_ASSETS, CACHE_STATIC, CACHE_APP];\n  event.waitUntil(\n    self.clients.claim()\n    /*\n    caches.keys().then(cacheNames => {\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\n    }).then(cachesToDelete => {\n      return Promise.all(cachesToDelete.map(cacheToDelete => {\n        return caches.delete(cacheToDelete);\n      }));\n    }).then(() => self.clients.claim())\n    */\n  )\n})\n\nconst extractVersion = (bodyHTML: string) => {\n  const idx1 = bodyHTML.indexOf(`name=\"build-version\"`)\n  if (idx1 === -1) return null\n  const idx2 = bodyHTML.indexOf(`\"`, idx1 + 28)\n  const buildNumber = bodyHTML.substring(idx2 + 1, idx2 + 7)\n  return buildNumber\n}\n\nconst versionToHour = (buildNumber: string) => {\n  const nowTime = Math.floor(Date.now() / 1000)\n  const buildTime = parseInt(buildNumber.toLowerCase(), 36) * 10\n  const seconds = nowTime - buildTime\n  const hours = Math.floor(seconds / 60 / 60)\n  const minutes = Math.floor((seconds - (hours * 60 * 60)) / 60)\n  const horasText = `${hours} hora${hours === 1 ? '' : 's'}`\n  let hace = `${horasText} ${minutes} min`\n  if (hours === 0) hace = `${minutes} min`\n  if (hours > 12) hace = `m\u00E1s de ${horasText}`\n  return hace\n}\n\nconst VersionInfo = { build: \"\", hasUpdated: false }\nexport const ClientIDPort: Map<number, MessagePort> = new Map()\n\n// ping / pong\nHandlersMap.set(99, async (message) => {\n  return { ...message, response: \"pong\" }\n})\n\nself._isLocal = self.origin.includes(\"localhost\") || self.origin.includes(\"127.0.0.1\")\n\n//Compara las versiones\nlet lastNewVersionChecked = 0\n\nHandlersMap.set(7, async (message) => {\n  const nowTime = Math.floor(Date.now() / 1000)\n  if (lastNewVersionChecked && nowTime - lastNewVersionChecked < 30) {\n    console.log(\"Saltando revisi\u00F3n de actualizaci\u00F3n.\")\n    return {}\n  }\n\n  const versionCurrent = message.version\n  if (!versionCurrent) {\n    console.log(\"No se envi\u00F3 la version (build) a comparar.\")\n    return {}\n  }\n  const versionHasUpdated = await compareVersionUpdate(versionCurrent)\n  lastNewVersionChecked = nowTime\n  return { versionHasUpdated }\n})\n\nconst compareVersionUpdate = async (versionCurrent: string): Promise<string> => {\n  VersionInfo.build = versionCurrent\n\n  const headers = new Headers()\n  headers.append('pragma', 'no-cache')\n  headers.append('cache-control', 'no-cache')\n\n  try {\n    const preResp = await fetch(self.location.origin + \"/app-version\", { method: 'GET', headers })\n    const bodyHTML = await preResp.text()\n    const versionUpdated = extractVersion(bodyHTML) || \"\"\n    VersionInfo.build = versionUpdated\n    console.log('build code compare fetch:: ', versionCurrent, \" | \", versionUpdated)\n\n    if (versionCurrent !== versionUpdated) {\n      await caches.delete(CACHE_ASSETS)\n      return versionToHour(versionUpdated)\n    }\n  } catch (error) {\n    console.warn('Error al obtener la versi\u00F3n nueva (HTML)::', error)\n  }\n  return \"\"\n}\n\n// The fetch handler serves responses for same-origin resources from a cache.\n// If no response is found, it populates the runtime cache with the response from the network before returning it to the page.\nconst clientIDsMap: Map<string, number> = new Map()\nconst usedRequestIDs: Map<number, number> = new Map()\nconst sendHandlers: Map<number, (c: any) => void> = new Map()\nexport const sendClientMessage = (clientID: number, content: any) => {\n  const handler = sendHandlers.get(clientID)\n  if (!handler) {\n    console.log(\"No se encontr\u00F3 el handler para el client:\", clientID, \"|\", content)\n  } else {\n    handler(content)\n  }\n}\n\nself.addEventListener('fetch', (event) => {\n  const request = event.request\n  const url = new URL(event.request.url)\n  //console.log(\"url recibida:\",url, url.pathname)\n\n  if (url.pathname === \"/_sw_\") {\n    event.respondWith((async () => {\n      // 3. Parse incoming data (from URL params or request body)\n      const accion = parseInt(url.searchParams.get('accion') || \"0\")\n      const reqID = parseInt(url.searchParams.get('req') || \"0\")\n      const enviroment = url.searchParams.get('env') || \"main\"\n\n      if (!clientIDsMap.has(event.clientId)) {\n        clientIDsMap.set(event.clientId, clientIDsMap.size + 1)\n      }\n      const clientID = clientIDsMap.get(event.clientId) || 0\n\n      const clientReqID = reqID * 1000 + clientID\n      const usedReqTime = usedRequestIDs.get(clientReqID) || 0\n      if (usedReqTime && (Date.now() - usedReqTime) < 1000) {\n        const haceMs = Date.now() - usedReqTime\n        console.log(\"El id \", reqID, \" est\u00E1 duplicado. | Client:\", event.clientId, \"| Hace:\", haceMs, \"ms\")\n        return new Response(JSON.stringify({ \"Error\": \"ReqID Duplicado.\" }), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n      usedRequestIDs.set(reqID, Date.now())\n\n\n      const client = await self.clients.get(event.clientId)\n      if (!client) {\n        console.warn(`No se encontr\u00F3 el client con ID ${event.clientId}`)\n        const msg = { error: `No se encontr\u00F3 el client con ID ${event.clientId}` }\n        return new Response(JSON.stringify(msg), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n\n      sendHandlers.set(clientID, (content: any) => {\n        client.postMessage(content)\n      })\n\n      const handler = HandlersMap.get(accion)\n      if (!handler) {\n        console.warn(`No se encontr\u00F3 el handler para la acci\u00F3n ${accion}`)\n        const msg = { error: `No se encontr\u00F3 el handler para la acci\u00F3n ${accion}` }\n        return new Response(JSON.stringify(msg), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n\n      // You MUST clone the request if you intend to read its body\n      // AND then potentially pass the original request on to fetch() later.\n      // Reading the body consumes the stream.\n      const requestClone = event.request.clone()\n      const content = await requestClone.json()\n\n      content.__enviroment__ = enviroment\n      content.__client__ = clientID\n\n      const response = await handler(content)\n      const message = { ...response, __response__: accion, __req__: reqID }\n      let info = \"\"\n      if (accion === 3) {\n        info = [content.route, content.cacheMode, reqID].join(\" | \")\n      }\n      // console.log(\"Respuesta a enviar:\", info, response)\n      client.postMessage(message)\n\n      // 5. Respond to the fetch request\n      console.log(`Respondiendo Fetch (${info}):`, (parseObject(message)))\n      return new Response(JSON.stringify({ \"ok\": 1 }), {\n        headers: { 'Content-Type': 'application/json' }\n      });\n    })())\n    return\n  } else if (url.searchParams.has(\"__cache__\")) {\n    const cacheParam = url.searchParams.get('__cache__') || \"\";\n    const [cacheTimeMinutes_, cacheVersion_, enviroment] = cacheParam.split('.')\n    const cacheTimeMinutes = parseInt(cacheTimeMinutes_)\n    const cacheVersion = parseInt(cacheVersion_)\n\n    if (isNaN(cacheTimeMinutes) || isNaN(cacheVersion)) {\n      console.warn(`Invalid __cache__ parameter format: ${cacheParam}. Bypassing cache.`);\n      return fetch(event.request);\n    }\n\n    // Create a canonical URL for caching, removing the __cache__ parameter\n    url.searchParams.delete('__cache__')\n    const cacheKey = url.toString()\n    console.log(\"buscando cach\u00E9:\", cacheKey)\n\n    event.respondWith((async () => {\n\n      const cache = await caches.open(`cache_req_${enviroment}`);\n      const cachedResponse = await cache.match(cacheKey);\n\n      const nowTime = Math.floor(Date.now() / 1000)\n\n      if (cachedResponse) {\n        const cachedTimestamp = parseInt(cachedResponse.headers.get('x-cache-timestamp') as string)\n        const cachedVersion = parseInt(cachedResponse.headers.get('x-cache-version') as string)\n\n        // Check for cache freshness and version\n        if (cachedTimestamp && cachedVersion &&\n          (nowTime - cachedTimestamp < cacheTimeMinutes * 60) && cachedVersion === cacheVersion) {\n          console.log(`Serving from cache: ${cacheKey}`)\n          return cachedResponse\n        } else {\n          console.log(`Cache stale or version mismatch for ${cacheKey}. Fetching new.`)\n          // If stale or version mismatch, proceed to fetch\n        }\n      }\n\n      // If no cached response, or if it's stale/version mismatch, fetch from network\n      try {\n        const networkResponse = await fetch(event.request)\n\n        // Clone the response because a response can only be consumed once\n        if(networkResponse.status === 200){\n          const responseToCache = networkResponse.clone()\n\n          // Add custom headers to the response to store timestamp and version\n          const headers = new Headers(responseToCache.headers)\n          headers.set('x-cache-timestamp', String(nowTime))\n          headers.set('x-cache-version', String(cacheVersion))\n  \n          const responseWithHeaders = new Response(await responseToCache.blob(), {\n            status: responseToCache.status,\n            statusText: responseToCache.statusText,\n            headers: headers\n          })\n  \n          await cache.put(cacheKey, responseWithHeaders)\n          console.log(`Fetched and cached: ${cacheKey}`)\n        } else {\n          console.log(`La consulta fall\u00F3::`, networkResponse.status)\n        }\n        return networkResponse;\n      } catch (error) {\n        console.error(`Fetch failed for ${cacheKey}:`, error)\n        // Optionally, you can return the cached response even if stale\n        // if a network error occurs (cache-first with network fallback)\n        if (cachedResponse) {\n          console.log(`Network failed, serving stale cache for ${cacheKey}`)\n          return cachedResponse\n        }\n        // Re-throw or return a network error response\n        throw error\n      }\n    })())\n  }\n\n  if (self._isLocal) {\n    return\n  }\n  const contentType = request.headers.get('Content-Type');\n\n  console.log(\"event URL:: \", request.url, \"|\", contentType)\n  if (!request.url.startsWith(self.location.origin)) return\n\n  const [filename, ext] = parseFileExtension(request.url)\n  if (filename === '/app-version') { return }\n\n  // 1. Determine if it's a navigation request for your SPA\n  const requestURL = new URL(request.url);\n  const isSameOrigin = requestURL.origin === self.location.origin;\n  // Request initiated by browser navigation (e.g., direct URL, refresh, link click)\n  const isHTMLNavigation = request.mode === 'navigate';\n  const hasNoExtension = !requestURL.pathname.includes('.') || requestURL.pathname === '/';\n\n\n  // como es una SPA todas las URL internas van hacia \"/\"\n  // ext === '*' significa que es una ruta interna del SAP (sin extension) en vez de un archivo \n  if (ext === '*') {\n    console.log(\"Re-routing Service Worker:: \", filename)\n  }\n\n  const CACHE_NAME = ['js', 'css', 'html', '*', 'ts', 'mjs', 'tsx'].includes(ext)\n    ? CACHE_ASSETS : CACHE_STATIC\n\n  const OFFLINE_URL = \"/\"\n\n  if (isSameOrigin && isHTMLNavigation && hasNoExtension) {\n    event.respondWith(\n      caches.open(CACHE_NAME).then(cache => {\n        return cache.match(OFFLINE_URL).then(cachedResponse => {\n          // If it's in the cache, return it immediately\n          if (cachedResponse && !navigator.onLine) {\n            console.log(`[Service Worker] Serving cached HTML for ${request.url} from ${OFFLINE_URL}`);\n            return cachedResponse;\n          }\n          // If not in cache, or no specific HTML for the current route was found,\n          // go to network for the original request URL\n          console.log(`[Service Worker] HTML not in cache, fetching from network: ${request.url}`);\n          return fetch(request)\n            .then(networkResponse => {\n              // Check if we received a valid HTML response\n              // We are specifically checking for 'text/html' for HTML caching\n              const contentType = networkResponse.headers.get('Content-Type');\n              if (networkResponse.ok && contentType && contentType.includes('text/html')) {\n                // Clone the response and store it in cache with the OFFLINE_URL key\n                // This means all successful HTML navigation responses\n                // will be saved as if they were the OFFLINE_URL ('/')\n                console.log(`[Service Worker] Caching new HTML response from ${request.url} as ${OFFLINE_URL}`);\n                cache.put(OFFLINE_URL, networkResponse.clone());\n              }\n              return networkResponse; // Return the network response to the browser\n            })\n            .catch(error => {\n              if (cachedResponse) {\n                return cachedResponse\n              }\n              // Network failed for HTML navigation.\n              console.error(`[Service Worker] Network failed for HTML navigation: ${request.url}`, error);\n              return new Response('<h1>Offline</h1><p>You appear to be offline and this content is not cached.</p>', {\n                headers: { 'Content-Type': 'text/html' }\n              });\n            });\n        });\n      })\n    )\n    return\n  }\n\n  // Skip cross-origin requests, like those for Google Analytics.\n  event.respondWith(\n    caches.open(\"cache_\").then(cache => {\n      return cache.match(request).then(cachedResponse => {\n\n        if (cachedResponse) {\n          const contentType = cachedResponse.headers.get(\"content-type\") || \"\"\n          if (!contentType.includes(\"/html\")) {\n            console.log('[Service Worker] Serving from cache:', request.url);\n            return cachedResponse\n          } else {\n            console.log(\"Es HTML!!\", ext)\n          }\n        }\n\n        return fetch(request)\n          .then(response => {\n            // Check if we received a valid response\n            if (!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n            const contentType = request.headers.get('Content-Type');\n            console.log(\"Guardando en cach\u00E9: \", CACHE_NAME, \" | \" + request.url, \" | \", contentType)\n\n            // Clone the response and put it in the opened cache\n            const responseToCache = response.clone();\n            console.log('[Service Worker] Caching new asset:', request.url);\n            cache.put(request, responseToCache); // Use the specific cache object for putting\n\n            return response;\n          })\n          .catch(error => {\n            console.error('[Service Worker] Fetch failed:', request.url, error)\n            return new Response('Network error occurred.',\n              { status: 503, statusText: 'Service Unavailable' });\n          })\n      })\n    })\n  )\n})\n\nconst appMemoryCache: Map<string, Map<string, any>> = new Map()\n\nexport const hasCacheKey = async (key: string, cache: string): Promise<any> => {\n  const cacheName = cache ? cache + \"_\" + CACHE_APP : CACHE_APP\n  const appCache = await caches.open(cacheName)\n  const hasCache = await appCache.match(key)\n  const memoryCache = appMemoryCache.get(cacheName)\n  if (!hasCache && memoryCache) { memoryCache.delete(key) }\n  return hasCache\n}\n\nexport const getCacheRecord = async (key: string, cache: string): Promise<any> => {\n  const cacheName = cache ? cache + \"_\" + CACHE_APP : CACHE_APP\n  if (!appMemoryCache.has(cacheName)) { appMemoryCache.set(cacheName, new Map()) }\n\n  const memoryCache = appMemoryCache.get(cacheName)\n  if (memoryCache?.has(key)) {\n    // Revisa si el cache realmente existe, eso debido a que puede haber sido eliminado y se debe limpiar tambien el que est\u00E1 en memoria\n    const cacheExists = await caches.has(cacheName)\n    if (cacheExists) {\n      return memoryCache.get(key)\n    } else {\n      appMemoryCache.set(cacheName, new Map())\n    }\n  }\n\n  const appCache = await caches.open(cacheName)\n  const startTime = Date.now()\n  const response = await appCache.match(key);\n  if (response) {\n    let jsonResponse = await response.json(); // Parse the response body as JSON\n    if (jsonResponse.__keys__) {\n      const keysMap = new Map(jsonResponse.__keys__) as Map<string, string | number>\n      // console.log(\"cache parsedContent 2\", jsonResponse.content, keysMap)\n      const keysMapReversed = new Map([...keysMap.entries()].map(x => [x[1], x[0]]))\n\n      jsonResponse = recreateObject(jsonResponse.content, keysMapReversed as unknown as Map<string, number>)\n    }\n    console.log(`Cache response \"${key}\" in ${Date.now() - startTime}ms (v2)`)\n    return jsonResponse\n  }\n  return undefined; // Or handle as you see fit if the key is not found\n};\n\nexport const setCacheRecord = async (key: string, content: any, cache: string): Promise<void> => {\n  const cacheName = cache ? cache + \"_\" + CACHE_APP : CACHE_APP\n  if (!appMemoryCache.has(cacheName)) { appMemoryCache.set(cacheName, new Map()) }\n  const appCache = await caches.open(cacheName)\n\n  const memoryCache = appMemoryCache.get(cacheName)\n  if (!content) { // Elimina el cach\u00E9 si se se\u00F1ala que no hay contenido\n    memoryCache?.delete(key)\n    await appCache.delete(key)\n    return\n  }\n  memoryCache?.set(key, content)\n\n  const startTime = Date.now()\n  if (typeof content !== 'string') {\n    /*\n    const keysMap = new Map()\n    const parsedContent = simplifyObject(content, keysMap)\n    content = JSON.stringify({ __keys__: [...keysMap.entries()], content: parsedContent }) \n    */\n    content = JSON.stringify(content)\n  }\n  // Create a Response object with the JSON content\n  const response = new Response(content, {\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': String(content.length)\n    }\n  });\n  await appCache.put(key, response);\n  console.log(`Cache put \"${key}\" in ${Date.now() - startTime}ms (v2)`)\n};\n\nexport const parseObject = (rec: any) => {\n\n  const newObject = {} as any\n\n  for(const key in rec){\n    const values = rec[key]\n    // console.log(\"v|\", values)\n    if(typeof values === 'number' || typeof values === 'string'){\n      newObject[key] = values\n    } else if(Array.isArray(values)){\n      newObject[key] = `[${values.length}]`\n    } else if(values && typeof values === 'object') {\n      newObject[key] = `{${Object.keys(values).join(\", \")}}`\n    }\n  }\n  return newObject\n}", "import { unmarshall } from \"$lib/unmarshall\"\nimport { CACHE_APP, getCacheRecord, HandlersMap, hasCacheKey, parseObject, sendClientMessage, setCacheRecord } from \"./service-worker-cache\"\n\nexport type CacheMode = 'offline' | 'updateOnly' | 'refresh' | 'fetchOnly'\n\nexport type serviceHttpProps = {\n  __enviroment__: string\n  __accion__: number\n  __client__: number\n  __req__?: number\n  __version__?: number /* version del cach\u00E9 */\n  route: string\n  module?: string\n  routeParsed?: string\n  headers?: { [e: string]: string } | Headers\n  keyID?: string | string[]\n  keysIDs?: { [e: string]: string | string[] }\n  fields?: string[]\n  keyFilterIfEmpty?: string\n  keyForUpdated?: string\n  cacheMode?: CacheMode\n  contentLength?: number\n  partition?: { \n    key: string, value: string | number, param?: string\n  }\n  status?: { code: number, message: string }\n  updatedStatus?: { [e: string]: string }\n  cacheSyncTime?: number\n  useCache?: { \n    min: number, /* minutos del cach\u00E9 */\n    ver: number  /* versi\u00F3n del cach\u00E9 */\n  },\n  useCacheStatic?: { \n    min: number, /* minutos del cach\u00E9 */\n    ver: number  /* versi\u00F3n del cach\u00E9 */\n  },\n}\n\ntype CacheContent = { __version__?: number } & { [k: string]: any[] }\n\n// Parsea los headers de la respuesta crear un reader\nconst parseResponseAsStream = async (\n  fetchResponse: Response, props: serviceHttpProps\n) => {\n\n  const contentType = fetchResponse.headers.get(\"Content-Type\")\n\n  if (fetchResponse.status && props.status) {\n    props.status.code = fetchResponse.status\n    props.status.message = fetchResponse.statusText\n  }\n\n  if (fetchResponse.status === 200) { \n    const reader = fetchResponse.body?.getReader() as ReadableStreamDefaultReader<Uint8Array<ArrayBuffer>>\n    const stream = new ReadableStream({\n      start(controller) {\n        // fetchOnCourse++\n        return pump()\n        function pump(): Promise<void> {\n          return reader.read().then(({ done, value }): Promise<void> => {\n            // When no more data needs to be consumed, close the stream\n            if (done) {\n              controller.close()\n              return Promise.resolve()\n            }\n            sendClientMessage(props.__client__, { __response__: 5, bytes: value.length })\n            // Enqueue the next data chunk into our target stream\n            controller.enqueue(value)\n            return pump()\n          })\n        }\n      },\n    })\n    const responseStream = new Response(stream)\n    const responseText = await responseStream.text()\n    // console.log('responseText::', responseText)\n    if(props){ props.contentLength = responseText.length }\n    return Promise.resolve(JSON.parse(responseText))\n  }\n  else if (fetchResponse.status === 401) {\n    // document.dispatchEvent(new Event('userLogout'))\n    console.warn('Error 401, la sesi\u00F3n ha expirado.')\n  }\n  else if (fetchResponse.status !== 200) {\n    console.log(fetchResponse)\n    if (!contentType || contentType.indexOf(\"/json\") === -1) {\n      console.log('Parseando como texto')\n      return fetchResponse.text()\n    } else {\n      console.log('parseando como JSON')\n      return fetchResponse.json()\n    }\n  }\n}\n\nconst extractUpdated = (\n  obj: {[k: string]: any[]}, useMin?: boolean\n) => {\n  const updatedStatus: {[k: string]: number } = {}\n\n  for(const [key, values] of Object.entries(obj)){\n    if(values && !Array.isArray(values)){\n      continue\n    }\n    let maxOrMin = 0\n    for(const v of values||[]){\n      const updated = v.updated || v.upd || 0\n      if(useMin){\n        if(maxOrMin === 0 || updated < maxOrMin){ maxOrMin = updated }\n      } else {\n        if(updated > maxOrMin){ maxOrMin = updated }\n      }\n    }\n    updatedStatus[key] = maxOrMin\n  }\n  return updatedStatus\n}\n\nconst addToRoute = (route: string, key: string, value: (string|number)) => {\n  const sign = route.includes('?') ? \"&\" : \"?\"\n  if(typeof value === 'string'){\n    value = value.replace(\"?\",\"&\")\n  }\n  return route + `${sign}${key}=${value}`\n}\n\n// fecha para forzar el cache\nlet forceFetch = false\nlet forcedFetchRequests: Set<string> = new Set()\n\nHandlersMap.set(11, async ()=> {\n  forceFetch = true\n  forcedFetchRequests = new Set()\n  setTimeout(() => { forceFetch = false },8000)\n  return { ok: 1 }\n})\n\nHandlersMap.set(3, async (args: serviceHttpProps) => {\n  return await fetchCache(args)\n})\n\nconst makeKey = (args: serviceHttpProps): [string, string] => {\n  const key = [args.route, args.partition?.value||\"0\"].join(\"_\")\n  const cacheName = [args.__enviroment__||\"main\", args.module||\"?\"].join(\"_\")\n  return [key, cacheName]\n}\n\n// Obtiene los updated\nHandlersMap.set(12, async (args: serviceHttpProps)=> {\n  const [key, cacheName] = makeKey(args)\n  const lastSync: ILastSync = await getCacheRecord(key+\"_updated\", cacheName)\n  console.log(\"lastSync obtenido (1):\",args, args.route, key, lastSync)\n  const updatedStatus = lastSync?.updatedStatus || {}\n  return { updatedStatus, updated: lastSync?.fetchTime || 0  }\n})\n\ninterface ILastSync {\n  fetchTime: number\n  updatedStatus: {[k: string]: number }\n  forceNetwork?: boolean\n  __version__: number\n}\n\nconst getRecordKeys = (args: serviceHttpProps, field: string): string |string[] => {\n  const keyIDs = args.keysIDs && Object.hasOwn(args.keysIDs, field)\n    ? args.keysIDs[field]\n    : args.keyID || \"id\"\n  return keyIDs\n}\n\nconst getKeyValue = (record: any, keyIDs: string |string[]): (string|number) => {\n  if(typeof keyIDs === 'string'){\n    return record[keyIDs] || record.ID || 0\n  } else if(Array.isArray(keyIDs)){\n    const arr: (string|number)[] = []\n    for(const key of keyIDs){\n      if(record[key]){\n        arr.push(record[key])\n      } else {\n        return 0\n      }\n    }\n    return arr.join(\"_\")\n  } else {\n    return 0\n  }\n}\n\nexport interface IResponse { [k: string]: any[] }\n\nconst handleFetchResponse = async (\n  args: serviceHttpProps, lastSync: ILastSync, response: CacheContent, nowTime: number\n): Promise<any> => {\n\n  if(Array.isArray(response)){ response = { _default: response } }\n\n  const updatedStatusDelta = extractUpdated(response)\n  const updatedMinDelta = extractUpdated(response, true)\n\n  let hasChanged = false\n  for(const [key, updated] of Object.entries(updatedStatusDelta)){\n    if(!updated){ continue }\n    const prevUpdated = lastSync.updatedStatus[key]\n    if(updated !== prevUpdated){\n      lastSync.updatedStatus[key] = updated\n      hasChanged = true\n    }\n    if(updatedMinDelta[key] < prevUpdated){\n      console.warn(`Cache Error: En \"${args.route}\" [${key}] se est\u00E1n obteniendo registros con [updated] menor que el cach\u00E9 (${(response[key]||[]).length} recibidos)`)\n    }\n  }\n\n  console.log(\"Fetch cache ha cambiado?:\", hasChanged,\"|\",args.route,\"|\", updatedStatusDelta)\n  const [key, cacheName] = makeKey(args)\n  const keyUpdated = key+\"_updated\"\n  \n  if(!hasChanged && args.cacheMode !== 'updateOnly'){\n    response = (await getCacheRecord(key, cacheName)) as { [k: string]: any[] }\n  } else if(hasChanged){\n    const prevResponse = (await getCacheRecord(key, cacheName)) as IResponse\n    console.log(\"cache obtenido:\",key,cacheName, args)\n\n    if(self._isLocal){\n      console.log(\"prevResponse (old)\", args.route, args.cacheMode, {...prevResponse})\n    }\n\n    const usedKeysCount: {[k: string]: number } = {}\n\n    for(const [respKey, newRecords] of Object.entries(response as IResponse)){\n      if((newRecords||[]).length === 0){ continue }\n\n      const keyIDs = getRecordKeys(args,respKey)\n\n      let missingCount = 0\n\n      usedKeysCount[String(keyIDs)] = (usedKeysCount[String(keyIDs)]||0) + newRecords.length\n      // Combina los registros basados en el ID\n      // ***\n      const makeKeyID = (r: any) => {\n        const value = getKeyValue(r, keyIDs)\n        if(!value){ missingCount++ }\n        return value\n      }\n      \n      const prevRecords = prevResponse[respKey] || []\n      if(!Array.isArray(prevRecords)){ continue }\n\n      const recordsMap: Map<number|string,any> = new Map()\n\n      for(const e of prevRecords){ recordsMap.set(makeKeyID(e), e) }\n      for(const e of newRecords){ recordsMap.set(makeKeyID(e), e) }\n\n      if(missingCount > 0){\n        console.warn(`Cache Error: En \"${args.route}\" (${respKey}) hay ${missingCount} registros sin la key: ${keyIDs}`)\n      }\n      console.log(\"Cache usedKeysCount\", usedKeysCount)\n\n      const mergedRecords: any[] = []\n      for(const e of recordsMap.values()){\n        // if(args.keyFilterIfEmpty && !e[args.keyFilterIfEmpty]){ continue }\n        mergedRecords.push(e)\n      }\n\n      prevResponse[respKey] = mergedRecords\n    }\n\n    if(self._isLocal){\n      console.log(\"prevResponse (new)\", args.route, args.cacheMode, {...prevResponse})\n    }\n    setCacheRecord(key, prevResponse, cacheName)\n    response = prevResponse\n  } else {\n    response = null as unknown as CacheContent\n  }\n\n  lastSync.fetchTime = nowTime\n  setCacheRecord(keyUpdated, lastSync, cacheName)\n  return response\n}\n\n// Confirmaci\u00F3n del client que ha obtenido la respuesta enviada\nconst acknowledgeResponses: Set<number> = new Set()\n\nHandlersMap.set(21, async (args: serviceHttpProps)=> {\n  const reqID = (args.__req__||0) * 1000 + args.__client__\n  acknowledgeResponses.add(reqID)\n})\n\nconst fetchCache = async(args: serviceHttpProps) => {\n  console.log(\"Obteniendo fetch service worker:\",args.route,\"|\", args.cacheMode,\"|\",args.__req__,\"|\", args.__version__)\n\n  const [key, cacheName] = makeKey(args)\n  const keyUpdated = key+\"_updated\"\n\n  const makeStats = (content: any): string[] => {\n    if(!content || Object.keys(content).length === 0){ return [\"sin registros\"] }\n    // Revisa la cantidad de registros por key\n    const stats: string[] = []\n    for(const key of Object.keys(content)){\n      stats.push(`${key}=${(content[key]||[]).length}`)\n    }\n    return stats\n  }\n\n  const lastSyncEmpty = { \n    fetchTime: 0, updatedStatus: {}, __version__: args.__version__ \n  } as ILastSync\n\n  let lastSync: ILastSync = (await getCacheRecord(keyUpdated, cacheName)) || lastSyncEmpty\n\n  // Si la version ha cambiado, limpia el cach\u00E9\n  if(lastSync.fetchTime && lastSync.__version__ !== args.__version__){\n    console.log(`Linmpiando cach\u00E9, difererente versi\u00F3n ${args.__version__} > ${lastSync.__version__}. Route ${args.route}`)\n    lastSync = lastSyncEmpty\n    await setCacheRecord(keyUpdated, lastSync, cacheName)\n    await setCacheRecord(key, null, cacheName)\n  } else {\n    const isCachePresent = await hasCacheKey(key, cacheName)\n\n    // Limpia el lastfech si no se encontr\u00F3 el registro base\n    if(lastSync.fetchTime && !isCachePresent){\n      await setCacheRecord(keyUpdated, lastSyncEmpty, cacheName)\n      lastSync = lastSyncEmpty\n    // Si se encontr\u00F3 el registro base pero no el lastSync, entonces limpia el registro base\n    } else if(isCachePresent && !lastSync.fetchTime){\n      await setCacheRecord(key, null, cacheName)\n    }\n  }\n\n  if(args.cacheMode === 'offline'){\n    const content = await getCacheRecord(key, cacheName) as CacheContent\n    if(content && content.__version__ === args.__version__){\n      const updatedStatus = extractUpdated(content)\n\n      // Revisa si son diferentes\n      for(const [key, updated] of Object.entries(updatedStatus)){\n        let reSave = false\n        if(lastSync.updatedStatus[key] !== updated){\n          console.log(\"El updatedStatus difiere:\", args.route,\"|\",key,\"|\",lastSync.updatedStatus[key],\" vs \", updated)\n          lastSync.updatedStatus[key] = updated\n          reSave = true\n        }\n        if(reSave){\n          setCacheRecord(keyUpdated, lastSync, cacheName)\n        }\n      }\n    }\n\n    console.log(\"Enviando fetch response (offline):\", args.route)\n    console.log(`${args.route}: Retornando registros \"${args.cacheMode||\"normal\"}\". ${makeStats(content).join(\" | \")}`)\n\n    return { content: content?._default ? content._default : content  }\n  }\n\n  const fetchTime = Math.floor(Date.now()/1000)\n  args.status = { code: 200, message: \"\" }\n\n  try {\n\n    let route = args.routeParsed||args.route\n    if(args.partition && args.partition.value){\n      const param = args.partition.param || args.partition.key\n      route = addToRoute(route, param, args.partition.value)\n    }  \n\n    const hasCache = lastSync && lastSync.updatedStatus && lastSync.fetchTime\n    console.log(\"hasCache\", args.route, lastSync)\n\n    const fields = args.fields || []\n    for(const field of fields){\n      const updated = lastSync.updatedStatus[field] || 0\n      if(!updated){ route = addToRoute(route, field, 0) }\n    }\n\n    if(hasCache){\n      if(lastSync.updatedStatus._default){\n        route = addToRoute(route, \"updated\", lastSync.updatedStatus._default as number)\n      } else {\n        let minUpdated = 0\n        for(const [key, updated] of Object.entries(lastSync.updatedStatus)){\n          if(minUpdated === 0 || updated < minUpdated){ minUpdated = updated }\n          if(fields.length > 0 && !fields.includes(key)){ continue }\n          route = addToRoute(route, key, updated as number)\n        }\n        route = addToRoute(route, \"updated\", minUpdated)\n      }\n\n      // Revisa si es necesario realizar una nuevo fetch\n      const cacheSyncTime = args.cacheSyncTime || args.useCache?.min || 0\n      const fetchNextTime = lastSync.fetchTime + (cacheSyncTime * 60)\n      const remainig = fetchNextTime - fetchTime\n\n      let doFetch = args.cacheMode === \"refresh\"\n      if(lastSync.forceNetwork){\n        console.log(\"Forzando fetch por flag forceNetwork en ILastSync:\",args.route)\n        doFetch = true\n        lastSync.forceNetwork = false // Resetear el flag\n        await setCacheRecord(keyUpdated, lastSync, cacheName) // Persistir el reseteo\n      } else if(forceFetch && !forcedFetchRequests.has(key)){\n        console.log(\"Forzando fetch por flag global:\",args.route)\n        doFetch = true\n      } else if(remainig <= 0){\n        console.log(\"Preparando fetch: \",args.route,\" | Last: \", lastSync.fetchTime,\"| Remainig:\", remainig)\n        doFetch = true\n      }\n\n      for(const field of args.fields || []){\n        const updated = lastSync.updatedStatus[field] || 0\n        if(!updated){ doFetch = true }\n      }\n\n      if(!doFetch){\n        const remainig = fetchNextTime - fetchTime\n        console.log(`Obviando sync fech \"${key}\". Quedan ${remainig}s`)\n        if(args.cacheMode === 'updateOnly'){\n          console.log(args.route, \"Retornando null por 'updated only'\")\n          return { content: null }\n        } else {\n          const content = await getCacheRecord(key, cacheName)\n          console.log(`${args.route}: Retornando registros \"${args.cacheMode||\"normal\"}`, parseObject(content))\n          return {\n            content: content?._default ? content._default : content\n          }\n        }\n      }\n    }\n\n    console.log(`Realizando fetch (${route})...`)\n    const preResponse = await self.fetch(route, { headers: args.headers }) \n\n    if(preResponse.status && preResponse.status !== 200){\n      const responseText = await preResponse.text()\n      return { error: responseText }\n    }\n\n    let response = ((await parseResponseAsStream(preResponse, args))||{}) as CacheContent\n    console.log(\"response pre-unmarshall\", response)\n    response = unmarshall(response)\n    console.log(\"response post-unmarshall\", response)\n\n    if(Array.isArray(response.response) && typeof response.message === 'string'){\n      response = response.response as any\n    }\n\n    if(Array.isArray(response)){ response = { _default: response } }\n    response.__version__ = args.__version__\n\n    console.log(`Fetch response recibida! (${route}) | Has-cach\u00E9: ${hasCache}`)\n    // Revisa si hay data a actualizar\n    if(hasCache){\n      console.log(\"prevResponse (hasCache)\", args.route, args.cacheMode, {...response}) \n      response = await handleFetchResponse(args, lastSync, response, fetchTime)\n    } else {\n      const updatedStatus = extractUpdated(response)\n      Object.assign(lastSync, { fetchTime, updatedStatus })\n      setCacheRecord(keyUpdated, lastSync, cacheName)\n      console.log(\"prevResponse (recent)\", args.route, args.cacheMode, {...response}) \n      setCacheRecord(key, response, cacheName)\n    }\n\n    console.log(`${args.route}: Retornando registros \"${args.cacheMode||\"normal\"}\". ${makeStats(response).join(\" | \")}`)\n\n    return { content: response }\n  } catch (error) {\n    console.log(\"Fetch Error::\", error)\n    return { error: error }\n  }\n}\n\n// Handler para actualizar el cach\u00E9 luego que un POST/PUT ha obtenido informaci\u00F3n delta como si fuera un GET\ninterface ICacheSyncUpdate {\n  args: serviceHttpProps\n  response: any\n  __enviroment__: string\n}\n\nHandlersMap.set(13, async (args: ICacheSyncUpdate)=> {\n  const [keyUpdated, cacheName] = makeKey(args.args)+\"_updated\"\n  const lastFech = ((await getCacheRecord(keyUpdated, cacheName)) || {\n    fetchTime: 0, updatedStatus: {} }) as ILastSync\n  const nowTime = Math.floor(Date.now()/1000) - 5\n  args.args.__enviroment__ = args.__enviroment__\n  console.log(\"Guardando external fech response en cach\u00E9:\", args.args.route)\n  handleFetchResponse(args.args, lastFech, args.response, nowTime)\n})\n\nHandlersMap.set(14, async (args: serviceHttpProps) => {\n  const [key, cacheName] = makeKey(args);\n  const keyUpdated = key + \"_updated\";\n  const lastSync: ILastSync = (await getCacheRecord(keyUpdated, cacheName)) || { fetchTime: 0, updatedStatus: {} };\n  lastSync.forceNetwork = true;\n  await setCacheRecord(keyUpdated, lastSync, cacheName);\n  console.log(`ForceNetwork set to true for key: ${keyUpdated}`);\n  return { ok: 1 };\n});\n\nexport interface IGetCacheSubObject {\n  route: string\n  module: string\n  partValue?: string | number\n  propInResponse?: string /* por defecto _default */\n  filter?: string /* ejemplo: id=1,order=2 */\n}\n\nHandlersMap.set(15, async (args: IGetCacheSubObject)=> {\n  const keyArgs = {\n    route: args.route, module: args.module, partition: { value: args.partValue }\n  } as serviceHttpProps\n\n  const [key, cacheName] = makeKey(keyArgs)\n  const response = await getCacheRecord(key, cacheName)\n\n  if(!response){ return [] }\n  const records = response[args.propInResponse||\"_default\"]\n  if(!records){ return [] }\n\n  if(args.filter){\n    const filterKeyValues = args.filter.split(\",\").filter(x => x).map(x => {\n      const filter: (string|number)[] = x.split(\"=\")\n      if(!isNaN(filter[1] as unknown as number)){\n        filter.push(parseInt(filter[1] as string))\n      } else {\n        filter.push(0)\n      }\n      return filter\n    })\n    console.log(\"keyValues filters:\", filterKeyValues)\n\n    const filtered: any[] = []\n    for(const r of records){\n      for(const fil of filterKeyValues){\n        const value = r[fil[0]]\n        if(value === fil[1] || value === fil[2]){\n          filtered.push(r)\n        }\n      }\n    }\n    return filtered\n  } else {\n    return response\n  }\n})\n\n// Obtiene la cantidad de espacio de los registros obtenidos\nHandlersMap.set(22, async (args: { __enviroment__: string })=> {\n  console.log(\"obteniendo cantidad de registros obtenidos\")\n  const cacheStores = await caches.keys()\n  console.log(\"cache stores::\", cacheStores, \"| Env:\", args.__enviroment__)\n  const cacheStats: { module: string, name: string, size?: number }[] = []\n\n  for(const name of cacheStores){\n    if(!name.includes(\"_\")){ continue }\n    const [envirotment, module] = name.split(\"_\")\n    if(envirotment !== args.__enviroment__){ continue }\n    cacheStats.push({ name, module, size: 0 })\n  }\n\n  await Promise.all(cacheStats.map(e => {\n    return new Promise((resolve, reject) => {\n      let cache: Cache\n      caches.open(e.name)\n      .then(_cache => {\n        cache = _cache\n        return cache.keys()\n      })\n      .then(requests => {\n        return Promise.all(requests.map(async (request) => {\n          try {\n            // 4. Match the Request object to get the corresponding Response object\n            const response = await cache.match(request);\n            if (response) {\n              // 5. Get Content-Length from the Response headers\n              // Fallback to response.headers.get('content-length') for case-insensitivity\n              const contentLength = response.headers.get('Content-Length') || response.headers.get('content-length');\n              if(!e.size){ e.size = 0 }\n              e.size += parseInt(contentLength || '0', 10)\n            } else {\n              // Handle case where a request might not have a matching response (unlikely for cache.keys)\n              console.warn(`Service Worker: No matching response found for request in cache '${e.name}':`, request.url)\n            }\n          } catch (itemError) {\n            console.error(`Service Worker: Error matching request or getting size for ${request.url}:`, itemError)\n          }\n        }))\n      })\n      .then(() => {\n        resolve(0)\n      })\n      .catch(err => {\n        console.log(\"Error al obtener informacion del cach\u00E9:\", err)\n        reject(err)\n      })\n    })\n  }))\n\n  console.log(\"cacheStats\", cacheStats)\n\n  return { cacheStats }\n})\n\n//Funci\u00F3n para eliminar cach\u00E9\nHandlersMap.set(23, async (args: { __enviroment__: string, cacheName: string })=> {\n\n  console.log(`Eliminando cach\u00E9 \"${args.cacheName}\" (Enviroment ${args.__enviroment__})...`)\n\n  await caches.delete(args.cacheName)\n\n  console.log(`Cach\u00E9 \"${args.cacheName}\" eliminado! (Enviroment ${args.__enviroment__})...`)\n  \n  return { ok: 1 }\n})\n\n//Funci\u00F3n para refrescar cach\u00E9 async\ninterface IRefreshCache {\n  __enviroment__: string, module: string, routes: string[] \n}\nHandlersMap.set(24, async (args: IRefreshCache)=> {\n  const cacheName = [args.__enviroment__||\"main\", args.module||\"?\"].join(\"_\")\n  console.log(\"Setting ForceNerwork for routes: \",args.routes)\n\n  const cache = await caches.open(cacheName + \"_\"+ CACHE_APP)\n  const requests = await cache.keys()\n  const routesUpdated: Set<string> = new Set()\n\n  for (const request of requests) {\n    const cachedRoute = request.url.split(\"/\")[3]\n    if(!cachedRoute){ continue }\n    console.log(\"buscando request::\", cachedRoute)\n    for(const route of args.routes){\n      if(cachedRoute.startsWith(route) && cachedRoute.endsWith(\"_updated\") ){\n        const lastSync: ILastSync = (await getCacheRecord(cachedRoute, cacheName))\n        lastSync.forceNetwork = true\n        await setCacheRecord(cachedRoute, lastSync, cacheName)\n        routesUpdated.add(route)\n        break\n      }\n    }\n  }\n\n  console.log(`ForceNetwork = true for routes: ${[...routesUpdated].join(\", \")} | In ${requests.length}`)\n  return { ok: 1 }\n})"],
  "mappings": "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",
  "names": ["unmarshall", "encoded", "keysDef", "content", "keysMap", "k", "typeId", "fields", "maxIndex", "i", "idx", "name", "lastTypeId", "decode", "val", "header", "refBlock", "skipIndices", "populate", "valueStartIdx", "sub", "isSkipBlock", "h", "s", "result", "key", "values", "typeDef", "obj", "valIdx", "fieldName", "recreateObject", "obj", "keysMap", "x", "key", "value", "newKey", "i", "PRECACHE", "CACHE_ASSETS", "CACHE_STATIC", "CACHE_APP", "HandlersMap", "PRECACHE_URLS", "parseFileExtension", "filename", "ix1", "ix2", "ix3", "event", "cache", "currentCaches", "extractVersion", "bodyHTML", "idx1", "idx2", "versionToHour", "buildNumber", "nowTime", "buildTime", "seconds", "hours", "minutes", "horasText", "hace", "VersionInfo", "HandlersMap", "message", "lastNewVersionChecked", "nowTime", "versionCurrent", "versionHasUpdated", "compareVersionUpdate", "VersionInfo", "headers", "bodyHTML", "versionUpdated", "extractVersion", "CACHE_ASSETS", "versionToHour", "error", "clientIDsMap", "usedRequestIDs", "sendHandlers", "sendClientMessage", "clientID", "content", "handler", "event", "request", "url", "accion", "reqID", "enviroment", "clientReqID", "usedReqTime", "haceMs", "client", "msg", "info", "parseObject", "cacheParam", "cacheTimeMinutes_", "cacheVersion_", "cacheTimeMinutes", "cacheVersion", "cacheKey", "cache", "cachedResponse", "cachedTimestamp", "cachedVersion", "networkResponse", "responseToCache", "responseWithHeaders", "contentType", "filename", "ext", "parseFileExtension", "requestURL", "isSameOrigin", "isHTMLNavigation", "hasNoExtension", "CACHE_NAME", "CACHE_STATIC", "OFFLINE_URL", "response", "appMemoryCache", "hasCacheKey", "key", "cacheName", "CACHE_APP", "hasCache", "memoryCache", "getCacheRecord", "appCache", "startTime", "jsonResponse", "keysMap", "keysMapReversed", "x", "recreateObject", "setCacheRecord", "rec", "newObject", "values", "parseResponseAsStream", "fetchResponse", "props", "contentType", "reader", "stream", "controller", "pump", "done", "value", "sendClientMessage", "responseText", "extractUpdated", "obj", "useMin", "updatedStatus", "key", "values", "maxOrMin", "v", "updated", "addToRoute", "route", "sign", "forceFetch", "forcedFetchRequests", "HandlersMap", "args", "fetchCache", "makeKey", "cacheName", "lastSync", "getCacheRecord", "getRecordKeys", "field", "getKeyValue", "record", "keyIDs", "arr", "handleFetchResponse", "response", "nowTime", "updatedStatusDelta", "updatedMinDelta", "hasChanged", "prevUpdated", "keyUpdated", "prevResponse", "usedKeysCount", "respKey", "newRecords", "missingCount", "makeKeyID", "r", "prevRecords", "recordsMap", "e", "mergedRecords", "setCacheRecord", "acknowledgeResponses", "reqID", "makeStats", "content", "stats", "lastSyncEmpty", "isCachePresent", "hasCacheKey", "reSave", "fetchTime", "param", "hasCache", "fields", "minUpdated", "cacheSyncTime", "fetchNextTime", "remainig", "doFetch", "parseObject", "preResponse", "unmarshall", "error", "lastFech", "keyArgs", "records", "filterKeyValues", "x", "filter", "filtered", "fil", "cacheStores", "cacheStats", "name", "envirotment", "module", "resolve", "reject", "cache", "_cache", "requests", "request", "contentLength", "itemError", "err", "CACHE_APP", "routesUpdated", "cachedRoute"]
}
