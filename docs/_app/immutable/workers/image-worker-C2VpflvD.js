const v={quality:50,qualityAlpha:-1,denoiseLevel:0,tileColsLog2:0,tileRowsLog2:0,speed:6,subsample:1,chromaDeltaQ:!1,sharpness:0,tune:0,enableSharpYUV:!1,bitDepth:8,lossless:!1};function w(e,t,s={}){let a;return t&&(a=(o,i)=>{const l=new WebAssembly.Instance(t,o);return i(l),l.exports}),e({noInitialRun:!0,instantiateWasm:a,...s})}const A=()=>(async e=>{try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(e)}catch{return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]));let r;const I=()=>typeof process<"u"&&process.release&&process.release.name==="node",q=()=>{var e;return((e=globalThis.caches)===null||e===void 0?void 0:e.default)!==void 0};async function B(e,t){let s=e,a=t;if(arguments.length===1&&!(e instanceof WebAssembly.Module)&&(s=void 0,a=e),!I()&&!q()&&await A()){const i=await import("./chunks/Cm81YUMe.js");return r=w(i.default,s,a),r}const o=await import("./chunks/Br9zCfzK.js");return r=w(o.default,s,a),r}async function M(e,t={}){r||(r=B());const s={...v,...t};if(s.bitDepth!==8&&s.bitDepth!==10&&s.bitDepth!==12)throw new Error("Invalid bit depth. Supported values are 8, 10, or 12.");if(!(e.data instanceof Uint16Array)&&s.bitDepth!==8)throw new Error("Invalid image data for bit depth. Must use Uint16Array for bit depths greater than 8.");s.lossless&&(t.quality!==void 0&&t.quality!==100&&console.warn("AVIF lossless: Quality setting is ignored when lossless is enabled (quality must be 100)."),t.qualityAlpha!==void 0&&t.qualityAlpha!==100&&t.qualityAlpha!==-1&&console.warn("AVIF lossless: QualityAlpha setting is ignored when lossless is enabled (qualityAlpha must be 100 or -1)."),t.subsample!==void 0&&t.subsample!==3&&console.warn("AVIF lossless: Subsample setting is ignored when lossless is enabled (subsample must be 3 for YUV444)."),s.quality=100,s.qualityAlpha=-1,s.subsample=3);const o=(await r).encode(new Uint8Array(e.data.buffer),e.width,e.height,s);if(!o)throw new Error("Encoding error.");return o.buffer}console.log("ðŸ”§ Image worker loaded and ready");let d=null;const D=async()=>{if(d!==null)return d;try{d=(await new OffscreenCanvas(1,1).convertToBlob({type:"image/avif"})).type==="image/avif"}catch{d=!1}return d};self.onmessage=async e=>{const{id:t,bitmap:s,blob:a,resolution:o,useJpeg:i,useAvif:l}=e.data;console.log("ðŸ“¨ Worker received message:",{id:t,hasBitmap:!!s,hasBlob:!!a,resolution:o,useJpeg:i,useAvif:l});try{let n;if(s)console.log("ðŸ–¼ï¸ Processing bitmap..."),n=s;else if(a){console.log("ðŸ–¼ï¸ Processing blob...");const u=a;console.log("ðŸ”„ Creating ImageBitmap from blob..."),n=await createImageBitmap(u),console.log("âœ… ImageBitmap created:",n.width,"x",n.height)}else{console.error("âŒ No bitmap or blob provided in message"),self.postMessage({id:t,error:"No bitmap or blob provided"});return}let b=o||1e3;b>2500&&(b=2500);const{width:f,height:p}=U(n.width,n.height,b);console.log("ðŸ“ Calculated dimensions:",{width:f,height:p});const g=new OffscreenCanvas(f,p),h=g.getContext("2d");h.drawImage(n,0,0,f,p);let c;if(l)if(console.log("ðŸ¥‘ Attempting AVIF conversion..."),await D())console.log("ðŸš€ Using native AVIF support"),c=await g.convertToBlob({type:"image/avif",quality:.8});else{console.log("ðŸ“¦ Using @jsquash/avif fallback");const u=h.getImageData(0,0,f,p),y=await M(u);c=new Blob([y],{type:"image/avif"})}else{const u=i?"image/jpeg":"image/webp";console.log(`ðŸŽ¨ Converting to ${u}...`),c=await g.convertToBlob({type:u,quality:.8})}console.log("ðŸŽ¨ Blob created:",c.size,"bytes",c.type);const m=await C(c);console.log("âœ… Data URL created, length:",m.length),self.postMessage({id:t,dataUrl:m}),console.log("ðŸ“¤ Response sent to main thread"),n.close()}catch(n){console.error("âŒ Error in worker:",n),self.postMessage({id:t,error:String(n)})}};const U=(e,t,s)=>{const a=e/t,o=e*t,i=s*s;if(i>o)return{width:e,height:t};let l=Math.sqrt(i*a),n=l/a;return l>e&&(l=e,n=t),{width:Math.round(l),height:Math.round(n)}};function C(e){return new Promise(t=>{const s=new FileReader;s.onloadend=()=>t(s.result),s.readAsDataURL(e)})}
