{
  "version": 3,
  "sources": ["../lib/unmarshall.ts", "../core/sharedHelpers.ts", "../workers/service-worker-cache.ts", "../workers/service-worker.ts"],
  "sourcesContent": ["/**\n * Unmarshalls a compact JSON array serialized by the serialize Go library.\n * The input should be an array [keys, content].\n *\n * @param encoded The serialized data [keys, content]\n * @returns The unmarshalled object or array\n */\nexport const unmarshall = (encoded: any): any => {\n  if (!Array.isArray(encoded) || encoded.length !== 2) {\n    return encoded;\n  }\n\n  const [keysDef, content] = encoded;\n  if (!Array.isArray(keysDef)) {\n    return encoded;\n  }\n\n  // Map to store type definitions: typeId -> { orderIdx -> fieldName }\n  const keysMap: Record<number, { fields: Record<number, string>; maxIndex: number }> = {};\n  for (const k of keysDef) {\n    if (!Array.isArray(k)) continue;\n    const typeId = k[0];\n    const fields: Record<number, string> = {};\n    let maxIndex = -1;\n    for (let i = 1; i < k.length; i += 2) {\n      const idx = k[i];\n      const name = k[i + 1];\n      fields[idx] = name;\n      if (idx > maxIndex) maxIndex = idx;\n    }\n    keysMap[typeId] = { fields, maxIndex };\n  }\n\n  let lastTypeId: number | null = null;\n\n  /**\n   * Decodes a value recursively based on headers.\n   */\n  const decode = (val: any): any => {\n    if (!Array.isArray(val) || val.length === 0) {\n      return val;\n    }\n\n    const header = val[0];\n\n    // Header 1: New object type\n    // Format: [1, [typeId, ...skipIndices], ...values]\n    if (header === 1) {\n      if (val.length < 2) return val;\n      const refBlock = val[1];\n      if (!Array.isArray(refBlock)) return val;\n      const typeId = refBlock[0];\n      const skipIndices = new Set<number>();\n      for (let i = 1; i < refBlock.length; i++) {\n        skipIndices.add(refBlock[i]);\n      }\n      lastTypeId = typeId;\n      return populate(typeId, val.slice(2), skipIndices);\n    }\n\n    // Header 0: Same type as previous object\n    // Format: [0, [skipIndices]?, ...values]\n    if (header === 0) {\n      if (lastTypeId === null) return val;\n\n      let skipIndices = new Set<number>();\n      let valueStartIdx = 1;\n\n      if (Array.isArray(val[1])) {\n        const sub = val[1];\n        let isSkipBlock = false;\n\n        if (sub.length > 0) {\n          const h = sub[0];\n          // If first element is not a valid header (0, 1, 2, 3), it's definitely a skip block\n          if (typeof h === 'number' && h !== 0 && h !== 1 && h !== 2 && h !== 3) {\n            isSkipBlock = true;\n          } else {\n            // If it is 0, 1, 2, or 3, it could be a skip block OR a value of the first field.\n            // Go's logic checks if the first field type is primitive.\n            // In TS, we don't have types, so we use the header rule as a heuristic.\n            isSkipBlock = typeof h === 'number' && h !== 0 && h !== 1 && h !== 2 && h !== 3;\n          }\n        }\n\n        if (isSkipBlock) {\n          for (const s of sub) {\n            if (typeof s === 'number') skipIndices.add(s);\n          }\n          valueStartIdx = 2;\n        }\n      }\n\n      return populate(lastTypeId, val.slice(valueStartIdx), skipIndices);\n    }\n\n    // Header 2: Array of values\n    // Format: [2, ...items]\n    if (header === 2) {\n      const result = [];\n      for (let i = 1; i < val.length; i++) {\n        result.push(decode(val[i]));\n      }\n      return result;\n    }\n\n    // Header 3: Map of key-value pairs\n    // Format: [3, key1, val1, key2, val2, ...]\n    if (header === 3) {\n      const result: Record<string, any> = {};\n      for (let i = 1; i < val.length; i += 2) {\n        if (i + 1 < val.length) {\n          const key = String(val[i]);\n          result[key] = decode(val[i + 1]);\n        }\n      }\n      return result;\n    }\n\n    // Fallback for plain arrays (header \"Other\")\n    return val.map(decode);\n  };\n\n  /**\n   * Populates an object of a given type with values and skip indices.\n   */\n  const populate = (typeId: number, values: any[], skipIndices: Set<number>) => {\n    const typeDef = keysMap[typeId];\n    if (!typeDef) return values;\n\n    const { fields, maxIndex } = typeDef;\n    const obj: Record<string, any> = {};\n    let valIdx = 0;\n    for (let i = 0; i <= maxIndex; i++) {\n      if (skipIndices.has(i)) {\n        continue;\n      }\n      if (valIdx >= values.length) {\n        break;\n      }\n      const fieldName = fields[i];\n      if (fieldName) {\n        obj[fieldName] = decode(values[valIdx]);\n      }\n      valIdx++;\n    }\n    return obj;\n  };\n\n  return decode(content);\n};\n", "export const recreateObject = (obj: any, keysMap: Map<string,string|number>): any => {\n  if(Array.isArray(obj)){ return obj.map(x => recreateObject(x, keysMap)) }\n  if(typeof obj !== 'object' || !obj || !obj._){ return obj }\n  for(const [key, value] of Object.entries(obj)){\n    if(keysMap.has(key)){\n      const newKey = keysMap.get(key)\n      if(newKey === key){ continue }\n      obj[newKey] = value\n      delete obj[key]\n    }\n  }\n\n  for(let i = 0; i < obj._.length; i+=2){\n    const key = keysMap.get(obj._[i])\n    obj[key] = recreateObject(obj._[i+1], keysMap)\n  }\n  delete obj._\n  return obj\n}\n\nexport const simplifyObject = (obj: any, keysMap: Map<string,string|number>): any => {\n  if(Array.isArray(obj)){ return obj.map(x => simplifyObject(x, keysMap)) }\n\n  if(typeof obj !== 'object' || !obj){ return obj }\n\n  const newObj = { _: [] as any[] } as {[key: string]: any  }\n  for(const [key, value] of Object.entries(obj)){\n    if(!keysMap.has(key)){\n      const id = keysMap.get(\"__count__\") as number || 0\n      keysMap.set(key, id+1)\n      keysMap.set(\"__count__\", id+1) \n    }\n    const id = keysMap.get(key)\n    if(typeof id === 'string'){\n      newObj[id] = value\n    } else {\n      newObj._.push(keysMap.get(key), simplifyObject(value, keysMap))\n    }\n  }\n  return newObj\n}\n\nexport const recreateArray = (records: any[]) => {\n  const keysMap = (records.find(x => x._keysMap) || {})._keysMap\n  if(keysMap){\n    const newRecords: any[] = []\n    for(const e of records){\n      if(e._keysMap){ continue }\n      newRecords.push(recreateObject(e, keysMap))\n    }\n    return newRecords\n  } else {\n    return records\n  }\n}\n", "/// <reference lib=\"WebWorker\" />\n\"use-strict\"\n\nimport { recreateObject } from \"../core/sharedHelpers\"\n\n// Names of the two caches used in this version of the service worker.\n// Change to v2, etc. when you update any of the local resources, which will\n// in turn trigger the install event again.\nconst PRECACHE = 'precache-v2'\nconst CACHE_ASSETS = 'assets-v2'\nconst CACHE_STATIC = 'static-v2'\nexport const CACHE_APP = 'app'\nexport const HandlersMap: Map<number, (input: any) => Promise<any>> = new Map()\n\n// A list of local resources we always want to be cached.\nconst PRECACHE_URLS: string[] = [\n  // 'index.html',\n  // './', // Alias for index.html\n]\n\nconst parseFileExtension = (filename: string) => {\n  const ix1 = filename.indexOf(\"?\")\n  if (ix1 !== -1) filename = filename.substring(0, ix1)\n  const ix2 = filename.indexOf(\"@\")\n  if (ix2 !== -1) filename = filename.substring(0, ix2)\n  filename = filename.substring(filename.indexOf(\"/\", 8))\n  const ix3 = filename.lastIndexOf(\".\")\n  if (filename === \"/\" || (ix3 === -1 && filename[2]) === \"/\") {\n    return [filename, \"*\"]\n  }\n  return [filename, filename.substring(ix3 + 1)]\n}\n\ndeclare const self: ServiceWorkerGlobalScope & {\n  __WB_MANIFEST: string[]\n  _isLocal: boolean\n};\n\n// The install handler takes care of precaching the resources we always need.\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(PRECACHE)\n      .then(cache => cache.addAll(PRECACHE_URLS))\n      .then(() => self.skipWaiting())\n  )\n})\n\n// The activate handler takes care of cleaning up old caches.\nself.addEventListener('activate', event => {\n  const currentCaches = [PRECACHE, CACHE_ASSETS, CACHE_STATIC, CACHE_APP];\n  event.waitUntil(\n    self.clients.claim()\n    /*\n    caches.keys().then(cacheNames => {\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\n    }).then(cachesToDelete => {\n      return Promise.all(cachesToDelete.map(cacheToDelete => {\n        return caches.delete(cacheToDelete);\n      }));\n    }).then(() => self.clients.claim())\n    */\n  )\n})\n\nconst extractVersion = (bodyHTML: string) => {\n  const idx1 = bodyHTML.indexOf(`name=\"build-version\"`)\n  if (idx1 === -1) return null\n  const idx2 = bodyHTML.indexOf(`\"`, idx1 + 28)\n  const buildNumber = bodyHTML.substring(idx2 + 1, idx2 + 7)\n  return buildNumber\n}\n\nconst versionToHour = (buildNumber: string) => {\n  const nowTime = Math.floor(Date.now() / 1000)\n  const buildTime = parseInt(buildNumber.toLowerCase(), 36) * 10\n  const seconds = nowTime - buildTime\n  const hours = Math.floor(seconds / 60 / 60)\n  const minutes = Math.floor((seconds - (hours * 60 * 60)) / 60)\n  const horasText = `${hours} hora${hours === 1 ? '' : 's'}`\n  let hace = `${horasText} ${minutes} min`\n  if (hours === 0) hace = `${minutes} min`\n  if (hours > 12) hace = `m\u00E1s de ${horasText}`\n  return hace\n}\n\nconst VersionInfo = { build: \"\", hasUpdated: false }\nexport const ClientIDPort: Map<number, MessagePort> = new Map()\n\n// ping / pong\nHandlersMap.set(99, async (message) => {\n  return { ...message, response: \"pong\" }\n})\n\nself._isLocal = self.origin.includes(\"localhost\") || self.origin.includes(\"127.0.0.1\")\n\n//Compara las versiones\nlet lastNewVersionChecked = 0\n\nHandlersMap.set(7, async (message) => {\n  const nowTime = Math.floor(Date.now() / 1000)\n  if (lastNewVersionChecked && nowTime - lastNewVersionChecked < 30) {\n    console.log(\"Saltando revisi\u00F3n de actualizaci\u00F3n.\")\n    return {}\n  }\n\n  const versionCurrent = message.version\n  if (!versionCurrent) {\n    console.log(\"No se envi\u00F3 la version (build) a comparar.\")\n    return {}\n  }\n  const versionHasUpdated = await compareVersionUpdate(versionCurrent)\n  lastNewVersionChecked = nowTime\n  return { versionHasUpdated }\n})\n\nconst compareVersionUpdate = async (versionCurrent: string): Promise<string> => {\n  VersionInfo.build = versionCurrent\n\n  const headers = new Headers()\n  headers.append('pragma', 'no-cache')\n  headers.append('cache-control', 'no-cache')\n\n  try {\n    const preResp = await fetch(self.location.origin + \"/app-version\", { method: 'GET', headers })\n    const bodyHTML = await preResp.text()\n    const versionUpdated = extractVersion(bodyHTML) || \"\"\n    VersionInfo.build = versionUpdated\n    console.log('build code compare fetch:: ', versionCurrent, \" | \", versionUpdated)\n\n    if (versionCurrent !== versionUpdated) {\n      await caches.delete(CACHE_ASSETS)\n      return versionToHour(versionUpdated)\n    }\n  } catch (error) {\n    console.warn('Error al obtener la versi\u00F3n nueva (HTML)::', error)\n  }\n  return \"\"\n}\n\n// The fetch handler serves responses for same-origin resources from a cache.\n// If no response is found, it populates the runtime cache with the response from the network before returning it to the page.\nconst clientIDsMap: Map<string, number> = new Map()\nconst usedRequestIDs: Map<number, number> = new Map()\nconst sendHandlers: Map<number, (c: any) => void> = new Map()\nexport const sendClientMessage = (clientID: number, content: any) => {\n  const handler = sendHandlers.get(clientID)\n  if (!handler) {\n    console.log(\"No se encontr\u00F3 el handler para el client:\", clientID, \"|\", content)\n  } else {\n    handler(content)\n  }\n}\n\nself.addEventListener('fetch', (event) => {\n  const request = event.request\n  const url = new URL(event.request.url)\n  //console.log(\"url recibida:\",url, url.pathname)\n\n  if (url.pathname === \"/_sw_\") {\n    event.respondWith((async () => {\n      // 3. Parse incoming data (from URL params or request body)\n      const accion = parseInt(url.searchParams.get('accion') || \"0\")\n      const reqID = parseInt(url.searchParams.get('req') || \"0\")\n      const enviroment = url.searchParams.get('env') || \"main\"\n\n      if (!clientIDsMap.has(event.clientId)) {\n        clientIDsMap.set(event.clientId, clientIDsMap.size + 1)\n      }\n      const clientID = clientIDsMap.get(event.clientId) || 0\n\n      const clientReqID = reqID * 1000 + clientID\n      const usedReqTime = usedRequestIDs.get(clientReqID) || 0\n      if (usedReqTime && (Date.now() - usedReqTime) < 1000) {\n        const haceMs = Date.now() - usedReqTime\n        console.log(\"El id \", reqID, \" est\u00E1 duplicado. | Client:\", event.clientId, \"| Hace:\", haceMs, \"ms\")\n        return new Response(JSON.stringify({ \"Error\": \"ReqID Duplicado.\" }), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n      usedRequestIDs.set(reqID, Date.now())\n\n\n      const client = await self.clients.get(event.clientId)\n      if (!client) {\n        console.warn(`No se encontr\u00F3 el client con ID ${event.clientId}`)\n        const msg = { error: `No se encontr\u00F3 el client con ID ${event.clientId}` }\n        return new Response(JSON.stringify(msg), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n\n      sendHandlers.set(clientID, (content: any) => {\n        client.postMessage(content)\n      })\n\n      const handler = HandlersMap.get(accion)\n      if (!handler) {\n        console.warn(`No se encontr\u00F3 el handler para la acci\u00F3n ${accion}`)\n        const msg = { error: `No se encontr\u00F3 el handler para la acci\u00F3n ${accion}` }\n        return new Response(JSON.stringify(msg), {\n          headers: { 'Content-Type': 'application/json' }\n        })\n      }\n\n      // You MUST clone the request if you intend to read its body\n      // AND then potentially pass the original request on to fetch() later.\n      // Reading the body consumes the stream.\n      const requestClone = event.request.clone()\n      const content = await requestClone.json()\n\n      content.__enviroment__ = enviroment\n      content.__client__ = clientID\n\n      const response = await handler(content)\n      const message = { ...response, __response__: accion, __req__: reqID }\n      let info = \"\"\n      if (accion === 3) {\n        info = [content.route, content.cacheMode, reqID].join(\" | \")\n      }\n      // console.log(\"Respuesta a enviar:\", info, response)\n      client.postMessage(message)\n\n      // 5. Respond to the fetch request\n      console.log(`Respondiendo Fetch (${info}):`, (parseObject(message)))\n      return new Response(JSON.stringify({ \"ok\": 1 }), {\n        headers: { 'Content-Type': 'application/json' }\n      });\n    })())\n    return\n  } else if (url.searchParams.has(\"__cache__\")) {\n    const cacheParam = url.searchParams.get('__cache__') || \"\";\n    const [cacheTimeMinutes_, cacheVersion_, enviroment] = cacheParam.split('.')\n    const cacheTimeMinutes = parseInt(cacheTimeMinutes_)\n    const cacheVersion = parseInt(cacheVersion_)\n\n    if (isNaN(cacheTimeMinutes) || isNaN(cacheVersion)) {\n      console.warn(`Invalid __cache__ parameter format: ${cacheParam}. Bypassing cache.`);\n      return fetch(event.request);\n    }\n\n    // Create a canonical URL for caching, removing the __cache__ parameter\n    url.searchParams.delete('__cache__')\n    const cacheKey = url.toString()\n    console.log(\"buscando cach\u00E9:\", cacheKey)\n\n    event.respondWith((async () => {\n\n      const cache = await caches.open(`cache_req_${enviroment}`);\n      const cachedResponse = await cache.match(cacheKey);\n\n      const nowTime = Math.floor(Date.now() / 1000)\n\n      if (cachedResponse) {\n        const cachedTimestamp = parseInt(cachedResponse.headers.get('x-cache-timestamp') as string)\n        const cachedVersion = parseInt(cachedResponse.headers.get('x-cache-version') as string)\n\n        // Check for cache freshness and version\n        if (cachedTimestamp && cachedVersion &&\n          (nowTime - cachedTimestamp < cacheTimeMinutes * 60) && cachedVersion === cacheVersion) {\n          console.log(`Serving from cache: ${cacheKey}`)\n          return cachedResponse\n        } else {\n          console.log(`Cache stale or version mismatch for ${cacheKey}. Fetching new.`)\n          // If stale or version mismatch, proceed to fetch\n        }\n      }\n\n      // If no cached response, or if it's stale/version mismatch, fetch from network\n      try {\n        const networkResponse = await fetch(event.request)\n\n        // Clone the response because a response can only be consumed once\n        if(networkResponse.status === 200){\n          const responseToCache = networkResponse.clone()\n\n          // Add custom headers to the response to store timestamp and version\n          const headers = new Headers(responseToCache.headers)\n          headers.set('x-cache-timestamp', String(nowTime))\n          headers.set('x-cache-version', String(cacheVersion))\n  \n          const responseWithHeaders = new Response(await responseToCache.blob(), {\n            status: responseToCache.status,\n            statusText: responseToCache.statusText,\n            headers: headers\n          })\n  \n          await cache.put(cacheKey, responseWithHeaders)\n          console.log(`Fetched and cached: ${cacheKey}`)\n        } else {\n          console.log(`La consulta fall\u00F3::`, networkResponse.status)\n        }\n        return networkResponse;\n      } catch (error) {\n        console.error(`Fetch failed for ${cacheKey}:`, error)\n        // Optionally, you can return the cached response even if stale\n        // if a network error occurs (cache-first with network fallback)\n        if (cachedResponse) {\n          console.log(`Network failed, serving stale cache for ${cacheKey}`)\n          return cachedResponse\n        }\n        // Re-throw or return a network error response\n        throw error\n      }\n    })())\n  }\n\n  if (self._isLocal) {\n    return\n  }\n  const contentType = request.headers.get('Content-Type');\n\n  console.log(\"event URL:: \", request.url, \"|\", contentType)\n  if (!request.url.startsWith(self.location.origin)) return\n\n  const [filename, ext] = parseFileExtension(request.url)\n  if (filename === '/app-version') { return }\n\n  // 1. Determine if it's a navigation request for your SPA\n  const requestURL = new URL(request.url);\n  const isSameOrigin = requestURL.origin === self.location.origin;\n  // Request initiated by browser navigation (e.g., direct URL, refresh, link click)\n  const isHTMLNavigation = request.mode === 'navigate';\n  const hasNoExtension = !requestURL.pathname.includes('.') || requestURL.pathname === '/';\n\n\n  // como es una SPA todas las URL internas van hacia \"/\"\n  // ext === '*' significa que es una ruta interna del SAP (sin extension) en vez de un archivo \n  if (ext === '*') {\n    console.log(\"Re-routing Service Worker:: \", filename)\n  }\n\n  const CACHE_NAME = ['js', 'css', 'html', '*', 'ts', 'mjs', 'tsx'].includes(ext)\n    ? CACHE_ASSETS : CACHE_STATIC\n\n  const OFFLINE_URL = \"/\"\n\n  if (isSameOrigin && isHTMLNavigation && hasNoExtension) {\n    event.respondWith(\n      caches.open(CACHE_NAME).then(cache => {\n        return cache.match(OFFLINE_URL).then(cachedResponse => {\n          // If it's in the cache, return it immediately\n          if (cachedResponse && !navigator.onLine) {\n            console.log(`[Service Worker] Serving cached HTML for ${request.url} from ${OFFLINE_URL}`);\n            return cachedResponse;\n          }\n          // If not in cache, or no specific HTML for the current route was found,\n          // go to network for the original request URL\n          console.log(`[Service Worker] HTML not in cache, fetching from network: ${request.url}`);\n          return fetch(request)\n            .then(networkResponse => {\n              // Check if we received a valid HTML response\n              // We are specifically checking for 'text/html' for HTML caching\n              const contentType = networkResponse.headers.get('Content-Type');\n              if (networkResponse.ok && contentType && contentType.includes('text/html')) {\n                // Clone the response and store it in cache with the OFFLINE_URL key\n                // This means all successful HTML navigation responses\n                // will be saved as if they were the OFFLINE_URL ('/')\n                console.log(`[Service Worker] Caching new HTML response from ${request.url} as ${OFFLINE_URL}`);\n                cache.put(OFFLINE_URL, networkResponse.clone());\n              }\n              return networkResponse; // Return the network response to the browser\n            })\n            .catch(error => {\n              if (cachedResponse) {\n                return cachedResponse\n              }\n              // Network failed for HTML navigation.\n              console.error(`[Service Worker] Network failed for HTML navigation: ${request.url}`, error);\n              return new Response('<h1>Offline</h1><p>You appear to be offline and this content is not cached.</p>', {\n                headers: { 'Content-Type': 'text/html' }\n              });\n            });\n        });\n      })\n    )\n    return\n  }\n\n  // Skip cross-origin requests, like those for Google Analytics.\n  event.respondWith(\n    caches.open(\"cache_\").then(cache => {\n      return cache.match(request).then(cachedResponse => {\n\n        if (cachedResponse) {\n          const contentType = cachedResponse.headers.get(\"content-type\") || \"\"\n          if (!contentType.includes(\"/html\")) {\n            console.log('[Service Worker] Serving from cache:', request.url);\n            return cachedResponse\n          } else {\n            console.log(\"Es HTML!!\", ext)\n          }\n        }\n\n        return fetch(request)\n          .then(response => {\n            // Check if we received a valid response\n            if (!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n            const contentType = request.headers.get('Content-Type');\n            console.log(\"Guardando en cach\u00E9: \", CACHE_NAME, \" | \" + request.url, \" | \", contentType)\n\n            // Clone the response and put it in the opened cache\n            const responseToCache = response.clone();\n            console.log('[Service Worker] Caching new asset:', request.url);\n            cache.put(request, responseToCache); // Use the specific cache object for putting\n\n            return response;\n          })\n          .catch(error => {\n            console.error('[Service Worker] Fetch failed:', request.url, error)\n            return new Response('Network error occurred.',\n              { status: 503, statusText: 'Service Unavailable' });\n          })\n      })\n    })\n  )\n})\n\nconst appMemoryCache: Map<string, Map<string, any>> = new Map()\n\nexport const hasCacheKey = async (key: string, cache: string): Promise<any> => {\n  const cacheName = cache ? cache + \"_\" + CACHE_APP : CACHE_APP\n  const appCache = await caches.open(cacheName)\n  const hasCache = await appCache.match(key)\n  const memoryCache = appMemoryCache.get(cacheName)\n  if (!hasCache && memoryCache) { memoryCache.delete(key) }\n  return hasCache\n}\n\nexport const getCacheRecord = async (key: string, cache: string): Promise<any> => {\n  const cacheName = cache ? cache + \"_\" + CACHE_APP : CACHE_APP\n  if (!appMemoryCache.has(cacheName)) { appMemoryCache.set(cacheName, new Map()) }\n\n  const memoryCache = appMemoryCache.get(cacheName)\n  if (memoryCache?.has(key)) {\n    // Revisa si el cache realmente existe, eso debido a que puede haber sido eliminado y se debe limpiar tambien el que est\u00E1 en memoria\n    const cacheExists = await caches.has(cacheName)\n    if (cacheExists) {\n      return memoryCache.get(key)\n    } else {\n      appMemoryCache.set(cacheName, new Map())\n    }\n  }\n\n  const appCache = await caches.open(cacheName)\n  const startTime = Date.now()\n  const response = await appCache.match(key);\n  if (response) {\n    let jsonResponse = await response.json(); // Parse the response body as JSON\n    if (jsonResponse.__keys__) {\n      const keysMap = new Map(jsonResponse.__keys__) as Map<string, string | number>\n      // console.log(\"cache parsedContent 2\", jsonResponse.content, keysMap)\n      const keysMapReversed = new Map([...keysMap.entries()].map(x => [x[1], x[0]]))\n\n      jsonResponse = recreateObject(jsonResponse.content, keysMapReversed as unknown as Map<string, number>)\n    }\n    console.log(`Cache response \"${key}\" in ${Date.now() - startTime}ms (v2)`)\n    return jsonResponse\n  }\n  return undefined; // Or handle as you see fit if the key is not found\n};\n\nexport const setCacheRecord = async (key: string, content: any, cache: string): Promise<void> => {\n  const cacheName = cache ? cache + \"_\" + CACHE_APP : CACHE_APP\n  if (!appMemoryCache.has(cacheName)) { appMemoryCache.set(cacheName, new Map()) }\n  const appCache = await caches.open(cacheName)\n\n  const memoryCache = appMemoryCache.get(cacheName)\n  if (!content) { // Elimina el cach\u00E9 si se se\u00F1ala que no hay contenido\n    memoryCache?.delete(key)\n    await appCache.delete(key)\n    return\n  }\n  memoryCache?.set(key, content)\n\n  const startTime = Date.now()\n  if (typeof content !== 'string') {\n    /*\n    const keysMap = new Map()\n    const parsedContent = simplifyObject(content, keysMap)\n    content = JSON.stringify({ __keys__: [...keysMap.entries()], content: parsedContent }) \n    */\n    content = JSON.stringify(content)\n  }\n  // Create a Response object with the JSON content\n  const response = new Response(content, {\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': String(content.length)\n    }\n  });\n  await appCache.put(key, response);\n  console.log(`Cache put \"${key}\" in ${Date.now() - startTime}ms (v2)`)\n};\n\nexport const parseObject = (rec: any) => {\n\n  const newObject = {} as any\n\n  for(const key in rec){\n    const values = rec[key]\n    // console.log(\"v|\", values)\n    if(typeof values === 'number' || typeof values === 'string'){\n      newObject[key] = values\n    } else if(Array.isArray(values)){\n      newObject[key] = `[${values.length}]`\n    } else if(values && typeof values === 'object') {\n      newObject[key] = `{${Object.keys(values).join(\", \")}}`\n    }\n  }\n  return newObject\n}", "import { unmarshall } from \"$lib/unmarshall\"\nimport { CACHE_APP, getCacheRecord, HandlersMap, hasCacheKey, parseObject, sendClientMessage, setCacheRecord } from \"./service-worker-cache\"\n\nexport type CacheMode = 'offline' | 'updateOnly' | 'refresh' | 'fetchOnly'\n\nexport type serviceHttpProps = {\n  __enviroment__: string\n  __accion__: number\n  __client__: number\n  __req__?: number\n  __version__?: number /* version del cach\u00E9 */\n  route: string\n  module?: string\n  routeParsed?: string\n  headers?: { [e: string]: string } | Headers\n  keyID?: string | string[]\n  keysIDs?: { [e: string]: string | string[] }\n  fields?: string[]\n  keyFilterIfEmpty?: string\n  keyForUpdated?: string\n  cacheMode?: CacheMode\n  contentLength?: number\n  partition?: { \n    key: string, value: string | number, param?: string\n  }\n  status?: { code: number, message: string }\n  updatedStatus?: { [e: string]: string }\n  cacheSyncTime?: number\n  useCache?: { \n    min: number, /* minutos del cach\u00E9 */\n    ver: number  /* versi\u00F3n del cach\u00E9 */\n  },\n  useCacheStatic?: { \n    min: number, /* minutos del cach\u00E9 */\n    ver: number  /* versi\u00F3n del cach\u00E9 */\n  },\n}\n\ntype CacheContent = { __version__?: number } & { [k: string]: any[] }\n\n// Parsea los headers de la respuesta crear un reader\nconst parseResponseAsStream = async (\n  fetchResponse: Response, props: serviceHttpProps\n) => {\n\n  const contentType = fetchResponse.headers.get(\"Content-Type\")\n\n  if (fetchResponse.status && props.status) {\n    props.status.code = fetchResponse.status\n    props.status.message = fetchResponse.statusText\n  }\n\n  if (fetchResponse.status === 200) { \n    const reader = fetchResponse.body?.getReader() as ReadableStreamDefaultReader<Uint8Array<ArrayBuffer>>\n    const stream = new ReadableStream({\n      start(controller) {\n        // fetchOnCourse++\n        return pump()\n        function pump(): Promise<void> {\n          return reader.read().then(({ done, value }): Promise<void> => {\n            // When no more data needs to be consumed, close the stream\n            if (done) {\n              controller.close()\n              return Promise.resolve()\n            }\n            sendClientMessage(props.__client__, { __response__: 5, bytes: value.length })\n            // Enqueue the next data chunk into our target stream\n            controller.enqueue(value)\n            return pump()\n          })\n        }\n      },\n    })\n    const responseStream = new Response(stream)\n    const responseText = await responseStream.text()\n    // console.log('responseText::', responseText)\n    if(props){ props.contentLength = responseText.length }\n    return Promise.resolve(JSON.parse(responseText))\n  }\n  else if (fetchResponse.status === 401) {\n    // document.dispatchEvent(new Event('userLogout'))\n    console.warn('Error 401, la sesi\u00F3n ha expirado.')\n  }\n  else if (fetchResponse.status !== 200) {\n    console.log(fetchResponse)\n    if (!contentType || contentType.indexOf(\"/json\") === -1) {\n      console.log('Parseando como texto')\n      return fetchResponse.text()\n    } else {\n      console.log('parseando como JSON')\n      return fetchResponse.json()\n    }\n  }\n}\n\nconst extractUpdated = (\n  obj: {[k: string]: any[]}, useMin?: boolean\n) => {\n  const updatedStatus: {[k: string]: number } = {}\n\n  for(const [key, values] of Object.entries(obj)){\n    if(values && !Array.isArray(values)){\n      continue\n    }\n    let maxOrMin = 0\n    for(const v of values||[]){\n      const updated = v.updated || v.upd || 0\n      if(useMin){\n        if(maxOrMin === 0 || updated < maxOrMin){ maxOrMin = updated }\n      } else {\n        if(updated > maxOrMin){ maxOrMin = updated }\n      }\n    }\n    updatedStatus[key] = maxOrMin\n  }\n  return updatedStatus\n}\n\nconst addToRoute = (route: string, key: string, value: (string|number)) => {\n  const sign = route.includes('?') ? \"&\" : \"?\"\n  if(typeof value === 'string'){\n    value = value.replace(\"?\",\"&\")\n  }\n  return route + `${sign}${key}=${value}`\n}\n\n// fecha para forzar el cache\nlet forceFetch = false\nlet forcedFetchRequests: Set<string> = new Set()\n\nHandlersMap.set(11, async ()=> {\n  forceFetch = true\n  forcedFetchRequests = new Set()\n  setTimeout(() => { forceFetch = false },8000)\n  return { ok: 1 }\n})\n\nHandlersMap.set(3, async (args: serviceHttpProps) => {\n  return await fetchCache(args)\n})\n\nconst makeKey = (args: serviceHttpProps): [string, string] => {\n  const key = [args.route, args.partition?.value||\"0\"].join(\"_\")\n  const cacheName = [args.__enviroment__||\"main\", args.module||\"?\"].join(\"_\")\n  return [key, cacheName]\n}\n\n// Obtiene los updated\nHandlersMap.set(12, async (args: serviceHttpProps)=> {\n  const [key, cacheName] = makeKey(args)\n  const lastSync: ILastSync = await getCacheRecord(key+\"_updated\", cacheName)\n  console.log(\"lastSync obtenido (1):\",args, args.route, key, lastSync)\n  const updatedStatus = lastSync?.updatedStatus || {}\n  return { updatedStatus, updated: lastSync?.fetchTime || 0  }\n})\n\ninterface ILastSync {\n  fetchTime: number\n  updatedStatus: {[k: string]: number }\n  forceNetwork?: boolean\n  __version__: number\n}\n\nconst getRecordKeys = (args: serviceHttpProps, field: string): string |string[] => {\n  const keyIDs = args.keysIDs && Object.hasOwn(args.keysIDs, field)\n    ? args.keysIDs[field]\n    : args.keyID || \"id\"\n  return keyIDs\n}\n\nconst getKeyValue = (record: any, keyIDs: string |string[]): (string|number) => {\n  if(typeof keyIDs === 'string'){\n    return record[keyIDs] || record.ID || 0\n  } else if(Array.isArray(keyIDs)){\n    const arr: (string|number)[] = []\n    for(const key of keyIDs){\n      if(record[key]){\n        arr.push(record[key])\n      } else {\n        return 0\n      }\n    }\n    return arr.join(\"_\")\n  } else {\n    return 0\n  }\n}\n\nexport interface IResponse { [k: string]: any[] }\n\nconst handleFetchResponse = async (\n  args: serviceHttpProps, lastSync: ILastSync, response: CacheContent, nowTime: number\n): Promise<any> => {\n\n  if(Array.isArray(response)){ response = { _default: response } }\n\n  const updatedStatusDelta = extractUpdated(response)\n  const updatedMinDelta = extractUpdated(response, true)\n\n  let hasChanged = false\n  for(const [key, updated] of Object.entries(updatedStatusDelta)){\n    if(!updated){ continue }\n    const prevUpdated = lastSync.updatedStatus[key]\n    if(updated !== prevUpdated){\n      lastSync.updatedStatus[key] = updated\n      hasChanged = true\n    }\n    if(updatedMinDelta[key] < prevUpdated){\n      console.warn(`Cache Error: En \"${args.route}\" [${key}] se est\u00E1n obteniendo registros con [updated] menor que el cach\u00E9 (${(response[key]||[]).length} recibidos)`)\n    }\n  }\n\n  console.log(\"Fetch cache ha cambiado?:\", hasChanged,\"|\",args.route,\"|\", updatedStatusDelta)\n  const [key, cacheName] = makeKey(args)\n  const keyUpdated = key+\"_updated\"\n  \n  if(!hasChanged && args.cacheMode !== 'updateOnly'){\n    response = (await getCacheRecord(key, cacheName)) as { [k: string]: any[] }\n  } else if(hasChanged){\n    const prevResponse = (await getCacheRecord(key, cacheName)) as IResponse\n    console.log(\"cache obtenido:\",key,cacheName, args)\n\n    if(self._isLocal){\n      console.log(\"prevResponse (old)\", args.route, args.cacheMode, {...prevResponse})\n    }\n\n    const usedKeysCount: {[k: string]: number } = {}\n\n    for(const [respKey, newRecords] of Object.entries(response as IResponse)){\n      if((newRecords||[]).length === 0){ continue }\n\n      const keyIDs = getRecordKeys(args,respKey)\n\n      let missingCount = 0\n\n      usedKeysCount[String(keyIDs)] = (usedKeysCount[String(keyIDs)]||0) + newRecords.length\n      // Combina los registros basados en el ID\n      // ***\n      const makeKeyID = (r: any) => {\n        const value = getKeyValue(r, keyIDs)\n        if(!value){ missingCount++ }\n        return value\n      }\n      \n      const prevRecords = prevResponse[respKey] || []\n      if(!Array.isArray(prevRecords)){ continue }\n\n      const recordsMap: Map<number|string,any> = new Map()\n\n      for(const e of prevRecords){ recordsMap.set(makeKeyID(e), e) }\n      for(const e of newRecords){ recordsMap.set(makeKeyID(e), e) }\n\n      if(missingCount > 0){\n        console.warn(`Cache Error: En \"${args.route}\" (${respKey}) hay ${missingCount} registros sin la key: ${keyIDs}`)\n      }\n      console.log(\"Cache usedKeysCount\", usedKeysCount)\n\n      const mergedRecords: any[] = []\n      for(const e of recordsMap.values()){\n        // if(args.keyFilterIfEmpty && !e[args.keyFilterIfEmpty]){ continue }\n        mergedRecords.push(e)\n      }\n\n      prevResponse[respKey] = mergedRecords\n    }\n\n    if(self._isLocal){\n      console.log(\"prevResponse (new)\", args.route, args.cacheMode, {...prevResponse})\n    }\n    setCacheRecord(key, prevResponse, cacheName)\n    response = prevResponse\n  } else {\n    response = null as unknown as CacheContent\n  }\n\n  lastSync.fetchTime = nowTime\n  setCacheRecord(keyUpdated, lastSync, cacheName)\n  return response\n}\n\n// Confirmaci\u00F3n del client que ha obtenido la respuesta enviada\nconst acknowledgeResponses: Set<number> = new Set()\n\nHandlersMap.set(21, async (args: serviceHttpProps)=> {\n  const reqID = (args.__req__||0) * 1000 + args.__client__\n  acknowledgeResponses.add(reqID)\n})\n\nconst fetchCache = async(args: serviceHttpProps) => {\n  console.log(\"Obteniendo fetch service worker:\",args.route,\"|\", args.cacheMode,\"|\",args.__req__,\"|\", args.__version__)\n\n  const [key, cacheName] = makeKey(args)\n  const keyUpdated = key+\"_updated\"\n\n  const makeStats = (content: any): string[] => {\n    if(!content || Object.keys(content).length === 0){ return [\"sin registros\"] }\n    // Revisa la cantidad de registros por key\n    const stats: string[] = []\n    for(const key of Object.keys(content)){\n      stats.push(`${key}=${(content[key]||[]).length}`)\n    }\n    return stats\n  }\n\n  const lastSyncEmpty = { \n    fetchTime: 0, updatedStatus: {}, __version__: args.__version__ \n  } as ILastSync\n\n  let lastSync: ILastSync = (await getCacheRecord(keyUpdated, cacheName)) || lastSyncEmpty\n\n  // Si la version ha cambiado, limpia el cach\u00E9\n  if(lastSync.fetchTime && lastSync.__version__ !== args.__version__){\n    console.log(`Linmpiando cach\u00E9, difererente versi\u00F3n ${args.__version__} > ${lastSync.__version__}. Route ${args.route}`)\n    lastSync = lastSyncEmpty\n    await setCacheRecord(keyUpdated, lastSync, cacheName)\n    await setCacheRecord(key, null, cacheName)\n  } else {\n    const isCachePresent = await hasCacheKey(key, cacheName)\n\n    // Limpia el lastfech si no se encontr\u00F3 el registro base\n    if(lastSync.fetchTime && !isCachePresent){\n      await setCacheRecord(keyUpdated, lastSyncEmpty, cacheName)\n      lastSync = lastSyncEmpty\n    // Si se encontr\u00F3 el registro base pero no el lastSync, entonces limpia el registro base\n    } else if(isCachePresent && !lastSync.fetchTime){\n      await setCacheRecord(key, null, cacheName)\n    }\n  }\n\n  if(args.cacheMode === 'offline'){\n    const content = await getCacheRecord(key, cacheName) as CacheContent\n    if(content && content.__version__ === args.__version__){\n      const updatedStatus = extractUpdated(content)\n\n      // Revisa si son diferentes\n      for(const [key, updated] of Object.entries(updatedStatus)){\n        let reSave = false\n        if(lastSync.updatedStatus[key] !== updated){\n          console.log(\"El updatedStatus difiere:\", args.route,\"|\",key,\"|\",lastSync.updatedStatus[key],\" vs \", updated)\n          lastSync.updatedStatus[key] = updated\n          reSave = true\n        }\n        if(reSave){\n          setCacheRecord(keyUpdated, lastSync, cacheName)\n        }\n      }\n    }\n\n    console.log(\"Enviando fetch response (offline):\", args.route)\n    console.log(`${args.route}: Retornando registros \"${args.cacheMode||\"normal\"}\". ${makeStats(content).join(\" | \")}`)\n\n    return { content: content?._default ? content._default : content  }\n  }\n\n  const fetchTime = Math.floor(Date.now()/1000)\n  args.status = { code: 200, message: \"\" }\n\n  try {\n\n    let route = args.routeParsed||args.route\n    if(args.partition && args.partition.value){\n      const param = args.partition.param || args.partition.key\n      route = addToRoute(route, param, args.partition.value)\n    }  \n\n    const hasCache = lastSync && lastSync.updatedStatus && lastSync.fetchTime\n    console.log(\"hasCache\", args.route, lastSync)\n\n    const fields = args.fields || []\n    for(const field of fields){\n      const updated = lastSync.updatedStatus[field] || 0\n      if(!updated){ route = addToRoute(route, field, 0) }\n    }\n\n    if(hasCache){\n      if(lastSync.updatedStatus._default){\n        route = addToRoute(route, \"updated\", lastSync.updatedStatus._default as number)\n      } else {\n        let minUpdated = 0\n        for(const [key, updated] of Object.entries(lastSync.updatedStatus)){\n          if(minUpdated === 0 || updated < minUpdated){ minUpdated = updated }\n          if(fields.length > 0 && !fields.includes(key)){ continue }\n          route = addToRoute(route, key, updated as number)\n        }\n        route = addToRoute(route, \"updated\", minUpdated)\n      }\n\n      // Revisa si es necesario realizar una nuevo fetch\n      const cacheSyncTime = args.cacheSyncTime || args.useCache?.min || 0\n      const fetchNextTime = lastSync.fetchTime + (cacheSyncTime * 60)\n      const remainig = fetchNextTime - fetchTime\n\n      let doFetch = args.cacheMode === \"refresh\"\n      if(lastSync.forceNetwork){\n        console.log(\"Forzando fetch por flag forceNetwork en ILastSync:\",args.route)\n        doFetch = true\n        lastSync.forceNetwork = false // Resetear el flag\n        await setCacheRecord(keyUpdated, lastSync, cacheName) // Persistir el reseteo\n      } else if(forceFetch && !forcedFetchRequests.has(key)){\n        console.log(\"Forzando fetch por flag global:\",args.route)\n        doFetch = true\n      } else if(remainig <= 0){\n        console.log(\"Preparando fetch: \",args.route,\" | Last: \", lastSync.fetchTime,\"| Remainig:\", remainig)\n        doFetch = true\n      }\n\n      for(const field of args.fields || []){\n        const updated = lastSync.updatedStatus[field] || 0\n        if(!updated){ doFetch = true }\n      }\n\n      if(!doFetch){\n        const remainig = fetchNextTime - fetchTime\n        console.log(`Obviando sync fech \"${key}\". Quedan ${remainig}s`)\n        if(args.cacheMode === 'updateOnly'){\n          console.log(args.route, \"Retornando null por 'updated only'\")\n          return { content: null }\n        } else {\n          const content = await getCacheRecord(key, cacheName)\n          console.log(`${args.route}: Retornando registros \"${args.cacheMode||\"normal\"}`, parseObject(content))\n          return {\n            content: content?._default ? content._default : content\n          }\n        }\n      }\n    }\n\n    console.log(`Realizando fetch (${route})...`)\n    const preResponse = await self.fetch(route, { headers: args.headers }) \n\n    if(preResponse.status && preResponse.status !== 200){\n      const responseText = await preResponse.text()\n      return { error: responseText }\n    }\n\n    let response = ((await parseResponseAsStream(preResponse, args))||{}) as CacheContent\n    console.log(\"response pre-unmarshall\", response)\n    response = unmarshall(response)\n    console.log(\"response post-unmarshall\", response)\n\n    if(Array.isArray(response.response) && typeof response.message === 'string'){\n      response = response.response as any\n    }\n\n    if(Array.isArray(response)){ response = { _default: response } }\n    response.__version__ = args.__version__\n\n    console.log(`Fetch response recibida! (${route}) | Has-cach\u00E9: ${hasCache}`)\n    // Revisa si hay data a actualizar\n    if(hasCache){\n      console.log(\"prevResponse (hasCache)\", args.route, args.cacheMode, {...response}) \n      response = await handleFetchResponse(args, lastSync, response, fetchTime)\n    } else {\n      const updatedStatus = extractUpdated(response)\n      Object.assign(lastSync, { fetchTime, updatedStatus })\n      setCacheRecord(keyUpdated, lastSync, cacheName)\n      console.log(\"prevResponse (recent)\", args.route, args.cacheMode, {...response}) \n      setCacheRecord(key, response, cacheName)\n    }\n\n    console.log(`${args.route}: Retornando registros \"${args.cacheMode||\"normal\"}\". ${makeStats(response).join(\" | \")}`)\n\n    return { content: response }\n  } catch (error) {\n    console.log(\"Fetch Error::\", error)\n    return { error: error }\n  }\n}\n\n// Handler para actualizar el cach\u00E9 luego que un POST/PUT ha obtenido informaci\u00F3n delta como si fuera un GET\ninterface ICacheSyncUpdate {\n  args: serviceHttpProps\n  response: any\n  __enviroment__: string\n}\n\nHandlersMap.set(13, async (args: ICacheSyncUpdate)=> {\n  const [keyUpdated, cacheName] = makeKey(args.args)+\"_updated\"\n  const lastFech = ((await getCacheRecord(keyUpdated, cacheName)) || {\n    fetchTime: 0, updatedStatus: {} }) as ILastSync\n  const nowTime = Math.floor(Date.now()/1000) - 5\n  args.args.__enviroment__ = args.__enviroment__\n  console.log(\"Guardando external fech response en cach\u00E9:\", args.args.route)\n  handleFetchResponse(args.args, lastFech, args.response, nowTime)\n})\n\nHandlersMap.set(14, async (args: serviceHttpProps) => {\n  const [key, cacheName] = makeKey(args);\n  const keyUpdated = key + \"_updated\";\n  const lastSync: ILastSync = (await getCacheRecord(keyUpdated, cacheName)) || { fetchTime: 0, updatedStatus: {} };\n  lastSync.forceNetwork = true;\n  await setCacheRecord(keyUpdated, lastSync, cacheName);\n  console.log(`ForceNetwork set to true for key: ${keyUpdated}`);\n  return { ok: 1 };\n});\n\nexport interface IGetCacheSubObject {\n  route: string\n  module: string\n  partValue?: string | number\n  propInResponse?: string /* por defecto _default */\n  filter?: string /* ejemplo: id=1,order=2 */\n}\n\nHandlersMap.set(15, async (args: IGetCacheSubObject)=> {\n  const keyArgs = {\n    route: args.route, module: args.module, partition: { value: args.partValue }\n  } as serviceHttpProps\n\n  const [key, cacheName] = makeKey(keyArgs)\n  const response = await getCacheRecord(key, cacheName)\n\n  if(!response){ return [] }\n  const records = response[args.propInResponse||\"_default\"]\n  if(!records){ return [] }\n\n  if(args.filter){\n    const filterKeyValues = args.filter.split(\",\").filter(x => x).map(x => {\n      const filter: (string|number)[] = x.split(\"=\")\n      if(!isNaN(filter[1] as unknown as number)){\n        filter.push(parseInt(filter[1] as string))\n      } else {\n        filter.push(0)\n      }\n      return filter\n    })\n    console.log(\"keyValues filters:\", filterKeyValues)\n\n    const filtered: any[] = []\n    for(const r of records){\n      for(const fil of filterKeyValues){\n        const value = r[fil[0]]\n        if(value === fil[1] || value === fil[2]){\n          filtered.push(r)\n        }\n      }\n    }\n    return filtered\n  } else {\n    return response\n  }\n})\n\n// Obtiene la cantidad de espacio de los registros obtenidos\nHandlersMap.set(22, async (args: { __enviroment__: string })=> {\n  console.log(\"obteniendo cantidad de registros obtenidos\")\n  const cacheStores = await caches.keys()\n  console.log(\"cache stores::\", cacheStores, \"| Env:\", args.__enviroment__)\n  const cacheStats: { module: string, name: string, size?: number }[] = []\n\n  for(const name of cacheStores){\n    if(!name.includes(\"_\")){ continue }\n    const [envirotment, module] = name.split(\"_\")\n    if(envirotment !== args.__enviroment__){ continue }\n    cacheStats.push({ name, module, size: 0 })\n  }\n\n  await Promise.all(cacheStats.map(e => {\n    return new Promise((resolve, reject) => {\n      let cache: Cache\n      caches.open(e.name)\n      .then(_cache => {\n        cache = _cache\n        return cache.keys()\n      })\n      .then(requests => {\n        return Promise.all(requests.map(async (request) => {\n          try {\n            // 4. Match the Request object to get the corresponding Response object\n            const response = await cache.match(request);\n            if (response) {\n              // 5. Get Content-Length from the Response headers\n              // Fallback to response.headers.get('content-length') for case-insensitivity\n              const contentLength = response.headers.get('Content-Length') || response.headers.get('content-length');\n              if(!e.size){ e.size = 0 }\n              e.size += parseInt(contentLength || '0', 10)\n            } else {\n              // Handle case where a request might not have a matching response (unlikely for cache.keys)\n              console.warn(`Service Worker: No matching response found for request in cache '${e.name}':`, request.url)\n            }\n          } catch (itemError) {\n            console.error(`Service Worker: Error matching request or getting size for ${request.url}:`, itemError)\n          }\n        }))\n      })\n      .then(() => {\n        resolve(0)\n      })\n      .catch(err => {\n        console.log(\"Error al obtener informacion del cach\u00E9:\", err)\n        reject(err)\n      })\n    })\n  }))\n\n  console.log(\"cacheStats\", cacheStats)\n\n  return { cacheStats }\n})\n\n//Funci\u00F3n para eliminar cach\u00E9 en base a un cacheName\nHandlersMap.set(23, async (args: { __enviroment__: string, cacheName: string })=> {\n\n  console.log(`Eliminando cach\u00E9 \"${args.cacheName}\" (Enviroment ${args.__enviroment__})...`)\n\n  await caches.delete(args.cacheName)\n\n  console.log(`Cach\u00E9 \"${args.cacheName}\" eliminado! (Enviroment ${args.__enviroment__})...`)\n  \n  return { ok: 1 }\n})\n\n\n//Funci\u00F3n para eliminar todo el cache\nHandlersMap.set(26, async (args: { __enviroment__: string })=> {\n  console.log(\"Eliminando cach\u00E9...\")\n\n  const cacheNames = await caches.keys();\n  for (const name of cacheNames) {\n    if (name.startsWith(args.__enviroment__)) {\n      console.log(`Eliminando cach\u00E9 por ambiente \"${args.__enviroment__}\": ${name}`);\n      await caches.delete(name);\n    }\n  }\n  \n  console.log(\"Cach\u00E9 eliminado.\")\n  return { ok: 1 }\n})\n\n//Funci\u00F3n para refrescar cach\u00E9 async\ninterface IRefreshCache {\n  __enviroment__: string, module: string, routes: string[] \n}\nHandlersMap.set(24, async (args: IRefreshCache)=> {\n  const cacheName = [args.__enviroment__||\"main\", args.module||\"?\"].join(\"_\")\n  console.log(\"Setting ForceNerwork for routes: \",args.routes)\n\n  const cache = await caches.open(cacheName + \"_\"+ CACHE_APP)\n  const requests = await cache.keys()\n  const routesUpdated: Set<string> = new Set()\n\n  for (const request of requests) {\n    const cachedRoute = request.url.split(\"/\")[3]\n    if(!cachedRoute){ continue }\n    console.log(\"buscando request::\", cachedRoute)\n    for(const route of args.routes){\n      if(cachedRoute.startsWith(route) && cachedRoute.endsWith(\"_updated\") ){\n        const lastSync: ILastSync = (await getCacheRecord(cachedRoute, cacheName))\n        lastSync.forceNetwork = true\n        await setCacheRecord(cachedRoute, lastSync, cacheName)\n        routesUpdated.add(route)\n        break\n      }\n    }\n  }\n\n  console.log(`ForceNetwork = true for routes: ${[...routesUpdated].join(\", \")} | In ${requests.length}`)\n  return { ok: 1 }\n})\n"],
  "mappings": "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",
  "names": ["content", "contentType", "key", "remainig"]
}
